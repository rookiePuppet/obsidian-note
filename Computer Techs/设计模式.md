
根据两条准则对设计模式进行分类：

1. 目的准则：模式用来完成什么工作
	1. 创建型：与对象的创建有关
	2. 结构性：处理类或对象的集合
	3. 行为型：描述类或对象如何交互和如何分配职责
2. 范围准则：模式主要用于类还是对象
	1. 类模式：处理类和子类之间的关系，在编译时确定
	2. 对象模式：处理对象间的关系，在运行时可变化

![[Pasted image 20250331105645.png]]

|     | 创建型                | 结构型       | 行为型                     |
| --- | ------------------ | --------- | ----------------------- |
| 类   | 将对象的部分创建工作延迟到子类    | 使用继承来组合类  | 使用继承描述算法和控制流            |
| 对象  | 将对象的部分创建工作延迟到另一个对象 | 描述对象的组装方式 | 描述一组对象如何协作完成单个对象无法完成的任务 |

# 创建型模式

创建型模式抽象了实例化过程，该模式有两个要点：

1. 将关于系统使用哪些具体的类的信息封装起来
2. 隐藏了这些类的实例是如何被创建和放在一起的

## 抽象工厂

> 意图

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。

> 适用性

- 一个系统要独立于它的产品的创建、组合和表示时
- 一个系统要由多个产品系列中的一个来配置时
- 当要强调一系列相关的产品对象的设计以便进行联合使用时
- 当提供一个产品类库，而只想显示它们的结构而不是实现时

> 结构

![[Pasted image 20250331153640.png]]

> 效果

1. 分离了具体的类
2. 使得易于交换产品系列
3. 有利于产品的一致性
4. 难以支持新种类的产品

## 生成器

> 意图

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

> 适用性

- 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时
- 当构造过程必须允许被构造的对象有不同的表示时

> 结构

![[Pasted image 20250331160339.png]]

> 效果

1. 使你可以改变一个产品的内部表示
2. 将构造代码和表示代码分开
3. 使你可对构造过程进行更精细的控制

## 工厂方法

> 意图 

定义一个用于创建对象的接口，让子类决定实例化哪一个类。

> 适用性

- 当一个类不知道它所必须创建的对象的类时
- 当一个类希望由它的子类来指定它所创建的对象时
- 当类将创建对象的职责委托给多个帮助子类中的某一个，并且你希望将哪一个帮助子类是代理者这一信息局部化时

> 结构

![[Pasted image 20250331162602.png]]

> 效果

1. 为子类提供挂钩
2. 连接平行的类层次

## 原型

> 意图

用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。

> 适用性

- 当一个系统应该独立于它的产品创建、构成和表示时
- 当要实例化的类实在运行时刻指定时
- 为了避免创建一个与产品类层次平行的工厂类层次时
- 当一个类的实例只能有几个不同状态组合中的一种时

> 结构

![[Pasted image 20250331165951.png]]

> 效果

1. 运行时增加和删除产品
2. 改变值以指定新对象
3. 改变结构已指定新对象
4. 减少子类的构造
5. 用类动态配置应用