在图像中找出被几何体占据的像素的过程，称为**光栅化**，物体顺序渲染也可以称为光栅化渲染。该过程所需的一系列操作——使物体转化为图像上的像素，就是**图形管线**。

> [!NOTE]
> 任何图形系统都有多种类型的图元对象，能够被直接处理，三角形就是其中一种，更复杂的对象都会被转换成这些图元。

对于大型场景，数据访问模式的管理非常影响性能。利用一个单独通道来一次性访问场景中的每一个几何，比重复搜索像素着色所需的物体更加高效。

两种类型的图形管线有着非常不同的目标：硬件管线通过像OpenGL和Direct3D这种API，被用于提供交互式渲染；软件管线提供像RenderMan这种API，被用于电影制作。硬件管线必须运行得足够快，以对游戏、可视化和用户界面实时反应。软件管线必须以最高质量渲染动画和视觉特效并是适应巨大的场景，而需要更多的时间。

物体顺序渲染需要完成的工作可分为三个部分：光栅化处理本身，光栅化之前的几何操作以及光栅化之后的像素操作。

最常见的几何操作是应用矩阵变换，将定义几何的点从模型空间映射到屏幕空间，从而使光栅器的输入以（屏幕空间中的）像素坐标表示。最常见的像素操作是**隐藏表面消除**，将更靠近观察者的表面组织到远离观察者的表面之前。

![[Pasted image 20250626172610.png]]

几何体数据一般被描述为顶点集，来自于交互式应用或场景描述文件中。这些顶点会在**顶点处理阶段**被处理，然后传递到**光栅化阶段**。光栅器将各个图元拆分成一堆**片元**，分别对应着被图元覆盖的一个像素。经过**片元处理阶段**，对应着每一个像素的各个片元在**片元混合阶段**被组合。

## 光栅化

光栅化是物体顺序渲染的核心操作，而**光栅器**是任何图形管线的核心。

光栅器会对输入的原型做两项工作：**枚举**被图元覆盖的像素并在图元表面**插值**计算属性值。光栅器的输出一个**片元**集合，一个片元对应着图元覆盖着的一个像素并携带它自己的属性集。

### 绘制直线

大多数图形库都包含绘制直线的命令，对于任意的屏幕坐标$(x_0,y_0)$和$(x_1,y_1)$，程序应该绘制一个“合理的”像素集得到两个端点之间的一条近似直线。

> 使用隐式直线方程绘制直线

使用隐式方程绘制直线的方法是**中点**算法，它和**布雷森汉姆**算法都能得到相同的结果，但在某种程度上更加直接。

首先写出这条直线的隐式方程：

$$
f(x,y)\equiv(y_0-y_1)x+(x_1-x_0)y+x_0y_1-x_1y_0=0
$$

该直线的斜率$m$为：

$$
m=\frac{y_1-y_0}{x_1-x_0}
$$

接下来的讨论假设$m\in(0,1]$，当$m\in(-\infty,-1],m\in(-1,0],m\in(1,\infty)$时也是相似的，这四种情况能覆盖所有的可能性。

![[Pasted image 20250627104810.png]]

中点算法的关键前提是绘制出没有缝隙的、最细的线条，两个像素之间的对角连接不认为是缝隙。该算法可以描述为：从左至右持续绘制像素，有时在$y$方向上要往上移动。

![[Pasted image 20250627104940.png]]

决定是否往上移动的一种有效方式就是看两个可能的像素中心连线的中点，如果直线穿过中点下方，那么就绘制下面这个像素，否则绘制上面那个像素。

![[Pasted image 20250627105802.png]]

例如，上一个像素的位置为$(x,y)$，下一个像素有可能被绘制在$(x+1,y)$和$(x+1,y+1)$，这两个候选位置的中点为$(x+1,y+0.5)$，然后判断直线和中点的位置关系。

通过将中点代入直线方程$f(x,y)$计算，若结果为正，说明该点在直线上方。

![[Pasted image 20250627112117.png]]

使用**增量**法可以更高效，增量法通过减少计算来使循环更有效率。

$$
\begin{align}
f(x + 1, y) &= f(x, y) + (y0 − y1)\\
f(x + 1, y + 1) &= f(x, y) + (y0 − y1) + (x1 − x0)
\end{align}
$$

![[Pasted image 20250627112826.png]]

### 三角形光栅化

我们经常需要用2D点绘制2D三角形，和绘制直线一样，我们可能希望在顶点上对颜色或其他属性进行插值。假设三个顶点的颜色分别为$c_0,c_1,c_2$，那么在三角形**质心坐标**$(\alpha,\beta,\gamma)$的颜色就是

$$
c=\alpha c_0 + \beta c_1 + \gamma c_2
$$

这类颜色插值在图形学中被称为**Gouraud**插值。

如果要光栅化具有共同顶点和边的三角形，可以通过中点算法先绘制出每一个三角形的轮廓，然后再填充中间的像素。

为了避免顺序问题和消除缝隙，最常见的做法就是当且仅当像素中心位置三角形内部时才绘制。

使用质心坐标能够啊帮助我们确定是否绘制一个像素以及像素应该是什么颜色，所以接下来就需要找到一种计算像素中心的质心坐标的方式。

暴力的光栅化算法为：

![[Pasted image 20250627115627.png]]

我们可以找到能够包围三个顶点的矩形，然后只遍历该矩形上的点。

![[Pasted image 20250627142005.png]]

$$
\begin{align}
f01(x, y) &= (y0 − y1)x + (x1 − x0)y + x0y1 − x1y0,\\
f12(x, y) &= (y1 − y2)x + (x2 − x1)y + x1y2 − x2y1,\\
f20(x, y) &= (y2 − y0)x + (x0 − x2)y + x2y0 − x0y2.
\end{align}
$$

![[Pasted image 20250627151341.png]]

> 处理三角形边上的像素

如果一个像素位于两个相邻三角形的同一条边上，最坏的做法就是不绘制该像素从而可能导致在两个相邻三角形之间产生缝隙，稍好一点的做法是对于两个三角形都绘制该像素，但是如果三角形是透明的，这回导致颜色重叠。

可以利用一个屏幕外的点只会出现在相邻边的某一侧的性质，来确保只对相邻边绘制一次。任意选取一个屏幕外的点，这里以$(-1,-1)$为例。

![[Pasted image 20250627161416.png]]

### 裁剪

仅仅将图元变换到屏幕空间然后光栅化它们并不能解决所有问题，这是因为在视体之外和眼睛后面的图元也会被光栅化，从而导致错误的结果。

![[Pasted image 20250627163816.png]]

两个顶点位于视体中，第三个位于眼睛后面，投影变换将该顶点映射到了远平面后一个无意义的位置上，这会导致光栅化出错。因此，在进行光栅化之前必须进行**裁剪**，移除眼睛后面的图元部分。

裁剪是图形学中的一个常见操作，只要一个几何实体切割另一个几何实体，就需要进行裁剪，在平面“错误”侧的三角形部分会被丢弃。

![[Pasted image 20250627164812.png]]

对于光栅化之前的裁剪来说，“错误”侧就是在视体之外的一侧。裁剪掉视体之外的所有几何总是安全的，即对视体的六个面都进行裁剪。

实现裁剪最常见的两种方法是：

1. 在世界坐标系中使用界定截头视锥体的六个平面进行裁剪
2. 在齐次除法前的4D变换空间中进行裁剪

对每一个三角形进行如下操作都可以实现上述两种方法。

![[Pasted image 20250627170116.png]]

### 在变换之前裁剪

这个方法唯一需要解决的问题就是“六个平面的方程”，因为这些方程对于渲染在同一张图像上的所有三角形来说都是相同的，不需要非常高效地计算它们。

出于这个原因，我们只需要使用视图-投影变换的逆矩阵将下面这八个顶点变换回世界空间，然后就能得到平面方程了。

$$
\begin{align}
(x, y, z) =&(l, b, n)\\
&(r, b, n)\\
&(l, t, n)\\
&(r, t, n)\\
&(l, b, f)\\
&(r, b, f)\\
&(l, t, f)\\
&(r, t, f)\\
\end{align}
$$

### 在齐次坐标中裁剪

令人惊讶的是，实际实现中通常选择的方案是在齐次除法前于**齐次坐标空间进行裁剪**。此处的视见体是4维的，并由3维体积（超平面）界定，具体方程为：

$$
\begin{align}
−x + lw = 0,  \\
x − rw = 0,  \\
−y + bw = 0,  \\
y − tw = 0,  \\
−z + nw = 0,  \\
z − fw = 0.
\end{align}
$$

这些平面方程极为简洁，因此效率比方案1更高。若将视见体 `[l, r] × [b, t] × [f, n]` 转换到 `[0, 1]³` 空间，还能进一步优化。事实证明，在此空间中对三角形进行裁剪的复杂度并不比3D空间高多少。

### 利用平面裁剪

无论选择哪种裁剪方式，都必须通过平面来裁剪。

一个经过点$p$，法线为$n$的平面，其隐式方程为$f(p)=n\cdot(p-q)=0$，通常写成$f(p)=n\cdot p + D=0$。

若有一条在点a和点b之间的线段，我们可以使用在BSP树程序中切割3D三角形边的技术来通过一个平面对线段进行裁剪。

通过计算$f(a)$和$f(b)$，根据它们的符号判断两个点是否位于平面的两侧。若平面分割了线段，那么我们就可以计算线段和平面的交点。

$$
n\cdot (a+t(b-a))+D=0
$$

得到$t=\frac{n\cdot a+D}{n\cdot(a-b)}$。

## 光栅化前后的操作

光栅化前的**顶点处理阶段**需要为光栅化准备顶点、颜色等插值所需的数据，输入该阶段的顶点会经过模型、视图和投影变换，映射到屏幕空间。同时，颜色、表面法线以及纹理坐标等信息也会根据需要进行变换。

光栅化后主要处理的是为每一个片元计算颜色和深度，该过程可以只是简单地将插值后的颜色和光栅器计算得到的深度值传递下去，也可以进行复杂的着色操作。

最后，混合阶段会将可能由多个图元产生的重叠片元组合起来，计算像素的最终颜色。最常见的混合方法就是选择深度值最小的片元的颜色。

### 简单的2D绘制

最简单的管线在顶点和片元阶段不做任何事情，而混合阶段只是用每一个片元的颜色覆盖上一次的颜色。应用程序直接提供片元的像素坐标，然后由光栅器完成所有工作。这种基础的方式是许多简单、老旧的API用来绘制用户界面、图表以及其他2D元素的根本。

### 最小的3D管线

只需要改变2D绘制管线中的一个矩阵变换，就可以绘制3D对象，即在顶点处理阶段将输入顶点乘以模型、摄像机、投影和视口矩阵的乘积。

3D管线需要解决的一个问题就是如何得到正确的遮挡关系，即让近处物体显示在远处物体的前面，这样图元就必须以从后往前的顺序进行绘制，这就是用于隐藏表面消除的**画家算法**。

画家算法的缺点在于它无法处理互相交叉的三角形，即使是不相互交叉的几个三角形也会形成**遮挡循环**。

![[Pasted image 20250630181000.png]]

### 使用Z-Buffer进行隐藏面消除

在实践中很少使用画家算法，而是使用另一种更简单高效的算法，叫做**z-Buffer**算法。

在每一个像素上，除了存储其颜色值之外，还记录一个目前为止到已绘制的最近表面的距离，即**深度值**。深度缓冲区或z缓冲区就是以深度值网格来命名的。

z-Buffer算法在片元混合阶段实现，通过比较每个片元与深度缓冲区中存储的值来决定是否覆盖当前像素。如果片元的深度更小，则其颜色值会覆盖当前像素颜色，并用其深度值更新深度缓冲区。如果片元深度更大，那么就会被丢弃。

片元所携带的深度值是通过将z坐标作为顶点属性进行插值得到的，和颜色值一样。

> 精度问题

由于在实际应用中，深度缓冲区存储的深度值是非负整数，这可能会导致一些精度问题。

我们可以将$(0,B-1)$映射到$z=(n,f)$，即每一个深度值发送到$\Delta z=(f-n)/B$的深度桶当中。

如果为深度值分配b位来存储，那么$B=2^b$，需要足够的位数来确保一个三角形前面的三角形的深度值被映射到不同的深度桶中。

使$\Delta z$变小的方法有两种，一是缩小n(近平面)和f(远平面)的距离，而是增加b。

### 逐顶点着色

在顶点处理阶段进行的着色计算叫做**顶点着色**，这种方式会对每个顶点，基于相机、光源和顶点位置计算观察方向和光源方向，然后根据着色方程来计算颜色。

顶点着色的缺点在于其细节不够丰富和真实，会产生伪影。因为它只对每一个顶点计算一次着色，而在顶点之间的数值是通过插值得到的。

### 逐片元着色

为了避免顶点着色带来的伪影，可以在顶点插值之后再进行着色计算来避免插值颜色，即在片元处理阶段执行**片元着色**。

片元着色可以使用和顶点着色相同的着色方程，但其使用的是插值向量。

### 纹理映射

**纹理**用于为那些看起来太单调且不自然的着色表面添加额外细节的一种图像。

使用纹理的方式非常简单，只需要在计算着色时，从纹理中读取需要的值（例如漫反射颜色）参与到着色当中，这个操作称为**纹理查找**：着色代码指定一个**纹理坐标**，然后纹理映射系统在纹理图像中找到该坐标对应的值并返回它。

定义纹理坐标最常见的方法就是将纹理坐标作为一个顶点属性，这样每一个图元就知道其在纹理中的对应位置。

### 着色频率

在哪里计算着色主要取决于颜色变化的速度，即所需细节的**尺度**。

具有**大尺度**特征的着色，例如曲面上的漫反射着色，可以相对较少地计算然后插值，即使用低**着色频率**。对于产生**小尺度**特征的着色，例如锐利的高光或精细的纹理，需要以高着色频率计算。

对于那些在图像中需要看起来清晰锐利的细节，着色的频率至少达到每像素一个着色样本。

在计算机游戏中使用的硬件管线，通常使用覆盖多个像素的图元来确保高效率，一般在片元上执行多数计算。另外，照片级真实感的RenderMan系统会先将所有表面细分为称为**微多边形**的小四边形之后，再逐顶点进行所有着色计算。