大多数计算机图像都是在**光栅显示器**在呈现给用户的，光栅显示器将图像作为一个像素的矩阵数组来显示。

> [!NOTE]
> 像素（pixel）是图片元素（picture element）的简称。

例如平板电脑或电视，它们都有一个很多发光的小像素矩形阵列，这些像素能够被单独设置成不同的颜色而创造出预期的图像。

不同的颜色是通过混合各种亮度的红绿蓝光而实现的。多数打印机如激光或喷墨打印机也都是光栅设备，它们基于扫描，虽然没有物理上的像素网格，但是图像是通过在网格选定的点上面沉积墨水而形成的。

> [!NOTE]
> 打印机中的颜色更加复杂，它涉及至少四种色彩的混合。

光栅在图像输入设备中也很常见。数码相机上的图像传感器是由一个光敏像素网格组成的，每一个像素会记录颜色和落在它上面的光强度。桌面扫描仪包含一个像素的线性阵列，它在纸张之间来回扫动，每秒做许多测量来产生一个像素网格。

由于光栅在各种设备中如此盛行，光栅图像是存储和处理图像的最普遍的方式。一张光栅图像只是一个简单的存储了每个像素值的二维数组，通常一个颜色用三个数字来分别存储红、绿、蓝。存储在内存中的光栅图像，可以将每个像素值一一映射到显示器的像素上来控制显色。

我们可能想要改变图像的尺寸或朝向，纠正颜色，甚至将图像贴在一个移动的三维表面上。即使是电视机，其显示器上的像素数量也极少和要显示的图像像素数量相同。这些思考打破了图像像素和显示像素之间的直接联系，最好将光栅图像理解为待显示图像的与设备无关的描述，而显示设备则是一种逼近理想图像的方式。

除了用像素数组描述图像之外，还有其他描述图像的方式。矢量图像通过存储对形状（由直线或曲线形成边界并附带颜色的区域）来描述图像，它没有引用任何特定的像素网格。在本质上，这更像是存储了显示图像的指令而非需要显示的像素。矢量图像的主要优势是与分辨率无关，而且可以很好地显示在超高分辨率的设备上，相应地，它们在被显示之前必须被光栅化是它的劣势。矢量图像经常用于文字、图标、机械绘图，以及其他需要高精度、摄影图像和不需要复杂着色的应用。

## 光栅设备

- 输出
	- 显示：
		- 透射式：液晶显示器（LCD）
		- 发射式：发光二极管显示器（LED）
	- 硬拷贝：
		- 二值：喷墨打印机
		- 连续色调：热转印打印机
- 输入：
	- 2D阵列传感器：数码相机
	- 1D阵列传感器：平台扫描器

发射式显示器利用像素直接发射出可控数量的光照，透射式显示器的像素本身并不发光，而是改变穿过它们的光量。透射式显示器需要一个光源来点亮它：在直观式显示器中它是像素阵列后的背光；在投影机中它是一盏发出光亮透过像素阵列后投影到屏幕上的灯。

LED显示器是发射式显示器的一个例子，它上面的每一个像素由一个或多个LED组成。显示器上的像素被划分为三种被独立控制的子像素：红色、绿色和蓝色，它们各自的LED使用不同的材料制作而成，因此能发出不同颜色的光。当从远处观看显示器时，眼睛无法分离出单独的子像素，从而感知到的颜色是红绿蓝的混合。

> [!NOTE]
> LED是一种半导体设备，其发光的强度由通过它的电流大小决定。

LCD显示器是透射式显示器的一个例子。液晶具有能让穿过它的光的偏振旋转的分子结构，旋转角度可以根据施加的电压来调节。一个LCD像素的背后有一层偏振膜，因此它会被偏振光（假设是水平的）所照亮。在像素的前面也有一层偏振膜，仅用于传导垂直的偏振光。若设定施加电压使液晶层不改变偏振方向，所有的光都被阻挡，像素处于关闭（最小亮度）状态；若设定电压使液晶将偏振旋转90°，从像素背面进入的所有光都从前面穿出，像素处于完全开启（最大亮度）状态；若电压处于中间值，偏振方向部分旋转使前偏振膜阻挡部分光，从而使像素的亮度介于最小值与最大值之间。

任何带有固定像素网格的显示器，都有一个基本固定的由网格大小决定的**分辨率**。对于显示器和图像，分辨率指的就是像素网格的规模。

> [!NOTE]
> 显示器的分辨率有时也叫做原生分辨率，因为多数显示器都能通过内置的转换来处理其他分辨率的图像。

### 硬拷贝设备

在纸上永久地记录图像和在显示器上临时地显示图像有着非常不同的约束。在打印中，色彩分布在纸上，从而当光在纸上反射时形成期望的图像。打印机像显示器一样是光栅设备，但许多打印机只能打印**二值图像**（在每一个网格位置上的色彩，只存在“有”和“无”两种状态，没有中间量）。

喷墨打印机通过扫描形成光栅图像，喷墨头上含有携带色彩的墨水，在电子控制下能喷射出极小的剂量。喷头在纸上移动时，只会在需要接收墨汁的网格位置上喷出墨滴，期望留白的区域不会喷出墨滴。彩印会使用多个喷头来混合不同颜色的墨滴。因为所有墨滴都是相同的，喷墨打印机打印的是二值图像：每一个网格点上要么有墨滴，要么没有墨滴，不存在中间着色。

喷墨打印机没有物理的像素阵列，其分辨率由墨滴的大小和扫过每一行后纸张移动的距离来决定。

**连续色调**打印的一个例子是**热转印**，这意味着在每一个像素上可以有不同剂量的染料被沉积。含有彩色染料的**供体色带**被压合在纸张（**染料接收层**）之间，喷头包含一列加热元件用于图像的每一列像素。当纸张和色带经过喷头时，加热元件对需要染料对应的色带区域加热，引起染料从色带向纸张扩散，对每一种染料的颜色重复此过程。因为越高的温度会导致更多的染料被转移，所以在每一个网格位置上每一种染料的量是可控的。打印头上加热元件的数量决定了页面横向的固定分辨率，而纵向分辨率则取决于加热/冷却速率与走纸速度的相对关系。

跟显示器不同，打印机的分辨率是用**像素密度**这个术语来描述的，而不是像素的总数。所以当热转印打印机的喷头上有每英寸300个加热元件排布时，它的页面横向分辨率就是300**像素每英寸**（ppi）。当喷墨打印机在一个每英寸有1200个网格点的网格上防止点时，它就有1200**点每英寸**（dpi）的分辨率。

由于喷墨打印机是二值设备，它需要一个更精细的网格。因为边缘是生硬的黑白边界，需要非常高的分辨率来避免锯齿。当打印连续色调图像时，需要高分辨率来通过打印不同密度的点阵（**中间色**）来模拟中间颜色。

### 输入设备

任何非算法计算得到的光栅图像都必须由光栅输入设备测量，多数时候是摄像机或扫描仪。即使是渲染3D场景的图像，照片也被用作纹理贴图。光栅输入设备必须对每一个像素测光，它们通常基于传感器阵列。

数码相机就是2D阵列输入设备的一种，摄像机中的图像传感器是一个带有光敏像素网格的半导体设备，最常见的两种类型是CCD（charge-coupled devices）和CMOS（complimentary metal-oxide-semiconductor）图像传感器。相机镜头将要拍摄的场景图像投射到传感器上，然后每一个像素会测量落在它上面的光能，最终产生一个数值到输出图像中。

大多数彩色摄像机会利用一个**色彩滤波阵列**（拜尔阵列）或**马赛克**，使每一个像素只能看到红、绿、蓝其中一种色光，让图像处理软件通过**去马赛克**来填充缺失的数值。

> [!NOTE]
> 去马赛克也叫做去拜尔化。由于色彩滤波阵列的存在，相机传感器直接输出的原始数据中，每个像素只有一种颜色通道的真实亮度值。该算法就是根据已知的单色像素值，通过复杂的数学插值和邻近像素分析，估算出另外两个颜色通道的值。

> 为什么只记录单通道值？不能直接把三个颜色通道都记录下来吗？

虽然将三通道值都记录下来而不通过算法计算的这种方法，能得到最还原的图像。但是在传感器相同面积的情况下，每一个感光点的进光量会大幅降低，另外其技术难度和成本都极高。

相比之下，拜尔阵列只记录单通道的方法最为经济高效，虽然牺牲了像素在色彩上的完整性，但提高了感光面积。去拜尔化算法的本质是基于邻域像素信息的插值和预测，在大部分场景下重建出的图像质量非常高，肉眼难以察觉到瑕疵。

相机的分辨率是由阵列上的固定像素数量决定的，通常用像素总数表示。一个带有3000列和2000行阵列的相机能输出一张分辨率为3000x2000的图像，也就是有600万像素，这样的相机也被称为6兆像素（MP）相机。

平台扫描仪和热转印打印机类似，也使用一个1D阵列对页面进行扫描，阵列的大小决定了其横向分辨率，而测量的频率相对扫描头移动的速度决定了纵向分辨率。

## 图像，像素，和几何

当我们测量或重现图像时，它们是光能的二维分布形式：从显示器发出的光作为显示屏幕位置的函数；落在相机图像传感器上的光作为传感器平面位置的函数；反射比或反射光的倒数作为一张纸上的位置的函数。因此在物理世界中，图像就是定义在二维区域上的函数，可以将它抽象为：

$$
I(x,y):R\rightarrow V
$$

$R$是一个矩阵区域，而$V$是像素值的集合。

光栅图像是如何与连续图像这个抽象概念联系起来的？来自相机和扫描仪中的像素是对像素周围一小块区域图像的平均颜色的测量；一个显示器像素被设计为红绿蓝三个子像素，使得像素上方图像的平均颜色被光栅图像中对应的像素值控制。在这两个例子中，像素值是图像颜色的局部平均，被称为图像的**点采样**。换句话说，当我们发现一个像素值为x，意思是在该网格点附近的图像值为x。

关于像素在2D空间中如何定位的问题，需要建立一个始终如一的约定。在本书中，光栅图像用表示行和列的$(i,j)$来索引，从左下角数起。如果一张图像有$n_x$列和$n_y$行像素，那么左下角像素就是$(0,0)$，右上角像素就是$(n_x-1,n_y-1$。我们需要二维的真实屏幕坐标来指定像素位置，于是将像素的采样点置于整数坐标上。

![[Pasted image 20250611115359.png]]

图像的矩阵域在网格的中央，这意味着它在两边的最后一个采样点之外延伸了半个像素的距离。因此一个矩形域为$n_x\times n_y$的图像为：

$$
R=[-0.5,n_x-0.5]\times [-0.5,n_y-0.5]
$$

### 像素值

目前为止，我们将像素值作为实数，表示图像中一个点的亮度（可能区分红、绿、蓝）。这说明图像应该是浮点数的数组，每一个像素可以是用一个（对于灰度或黑白图像）或三个（对于RGB彩色图像）32位浮点数存储的。当对数值的精度和范围有需求时，会使用这样的格式。但是用来存储和转换图像的内存和带宽总是稀缺的，仅仅是一张10MP的相片就要花费115MB的内存。

应该被直接显示的图像需要更小的范围，虽然光线强度的范围在理论上是没有边界的，但是任何设备显然都有一个有限的最大强度，因此在许多情况下，给像素一个边界范围是完全足够的，通常是$[0,1]$。

以浮点数存储的图像，允许有广范围的值，通常称为**高动态范围**（HDR）图像，以区分以整数存储的固定范围或**低动态范围**（LDR）图像。

下面是一些像素格式的典型应用：

- 1-bit 灰度：文本和其他不需要中间灰色的图像（高分辨率需求）
- 8-bit RGB固定范围颜色：网页和邮件应用，消费级相片
- 8或10-bit 固定范围RGB：计算机显示器的数字界面
- 12到14-bit 固定范围RGB：专业摄影使用的原始相机数据
- 16-bit 固定范围RGB：专业摄影和打印，固定范围图像处理的中间格式
- 16-bit 固定范围灰度：辐射学和医学图像
- 16-bit 半精度浮点RGB：HDR图像，实时渲染材质
- 32-bit 浮点RGB：软件渲染和HRD图像处理的通用中间格式

减少像素存储的比特数会导致图像中产生两种不同类型的伪影或人为引起的瑕疵。首先，当使用固定范围值编码的图像时，若像素超出设定的最大值，就会产生亮度**裁剪**。例如在阳光场景的照片中，某些反射光可能比白色表面更亮。当图像被转换成固定范围显示时，这些高光区域会被裁剪掉。其次，用有限精度编码的图像或导致**量化伪影**或**色彩断层**，当需要将像素值四舍五入到最近的可表示值时，会在亮度或颜色上产生肉眼可见的跳跃式突变。色彩断层尤其潜伏在动画和视频中，静止画面中的断层可能不易察觉，但是当断层前后移动时会变得非常明显。

### 显示器亮度和伽马

现代显示器将像素值的数字输入转换为一个亮度级别。现实中显示器在关闭时的亮度非零，因为屏幕会反射一些光线，我们将这作为“黑”，将显示器完全开启作为“白”。假设像素颜色的数值范围是从0到1，那么黑就是0，白就是1，介于黑白之间的灰色为0.5。

在显示器上产出正确的图像需要理解两个要点。第一是显示器相对输入是非线性的，比如说给显示器输入0，0.5和1.0，显示出的亮度可能是0，0.25和1.0。作为对这种非线性特性的近似描述，显示器常常以$\gamma$（伽马）值作为核心参数进行表征。该值是以下公式的自由度，其中$\alpha$是输入像素值。

$$
displayed\ \ intensity=(maximum\ \ intensity)\alpha^\gamma
$$

使用伽马来描述显示器的非线性特性仅仅是一种近似估计，我们不需要非常准确地计算设备的伽马值。

一种度量非线性特性的很棒的可视化方法是找到一个使显示亮度在黑和白之间的$\alpha$值：

$$
0.5=\alpha^\gamma
$$

若能找到这个$\alpha$值，我们可以通过对两边取对数来推算出伽马值：

$$
\gamma=\frac{\ln0.5}{\ln\alpha}
$$

可以通过一项标准的技术来找到$\alpha$值：在一块方形灰色像素旁边显示一个黑色相间的棋盘图案，接着让用户调整$\alpha$直到两边的亮度达到平均。

![[Pasted image 20250611162526.png]]

当$\alpha$值产生的亮度介于黑白之间时，从远处观察会发现两边看起来是一样的。其原理是模糊的棋盘混合了等量的黑色和白色的像素，在总体上就会呈现介于黑白之间的颜色的效果。

一旦知道了$\gamma$，我们就可以通过对输入进行**伽马校正**，来使$\alpha=0.5$时显示出黑白之间的中值亮度，伽马校正通过此变换来完成：

$$
a'=a^{\frac{1}{{\gamma}}}
$$

将其代入之前的公式即可得到

$$
\begin{align}
displayed\ \ intensity=(\alpha')^\gamma=(a^{\frac{1}{{\gamma}}})^\gamma(maximum\ \ intensity) \\
=a(maximum\ \ intensity)
\end{align}
$$

真实显示器的另一个重要特征是它们采用量化输入值。因此，虽然我们可以在$[0,1]$浮点数范围中操控亮度，但实际输入到显示器的是一个固定大小的整数，这个整数最常见的范围是0-255，需要8bit存储。这意味着$\alpha$可能的值不是0-1之间的任意数字，而是$\frac{0}{255},\frac{1}{255}...\frac{255}{255}$，那么可能的显示亮度值就近似为$M(\frac{0}{255})^\gamma,M(\frac{255}{255})^\gamma...M(\frac{255}{255})^\gamma$（其中M为最大亮度）。

## RGB颜色

RGB颜色空间的基本思想是，通过加法混合三原色（红、绿、蓝）光来显示颜色。

![[Pasted image 20250611171851.png]]

若允许从完全关闭到完全开启连续调节原色光，我们就可以创造出能够在RGB显示器上显示的所有颜色。红绿蓝像素值创建了一个拥有红、绿、蓝三个轴的RGB颜色立方体，每条轴的坐标范围从0到1。

![[Pasted image 20250611172413.png]]

实际的RGB强度通常是量化形式，每个分量分别由一个整数表示，最常见的整数大小为1字节，因此三个分量都是一个0-255的整数，总共是3个字节（24比特）。所以，一个“24-bit颜色”的系统在三原色上分别有256可能的强度值。

## 透明度混合

我们经常想要对像素内容部分覆盖，这常常发生在**混合**当中：在背景层上方插入一张前景图像。对于前景中的不透明像素，只需要用它替换掉背景像素；对于完全透明的前景像素，对背景像素无需更改；对于部分透明的像素，一些重要的地方必须被保留。当前景物体（比如玻璃）有部分透明的区域时，就会出现部分透明的像素。但是，前景和背景必须混合的最常见情形是当前景物体仅部分覆盖像素时，这发生在前景物体的边缘，或存在亚像素级镂空结构时（比如远景数目的枝叶间隙）。

在背景物体上方混合前景物体的关键信息是**像素覆盖率**，它表示被前景层覆盖的像素比例，将该比例记为$\alpha$。如果我们想在背景色$c_b$上混合前景色$c_f$，被前景覆盖的像素比例为$\alpha$，那么我们可以用这个公式：

$$
c=\alpha c_f + (1-\alpha)c_b
$$

对于一个不透明的前景层，前景物体在像素矩形上覆盖的面积为$\alpha$，背景物体覆盖剩余面积即$1-\alpha$。对于一个透明层（想象一张用半透明颜料绘制在玻璃上的图像），前景层阻挡了从背景透光量$1-\alpha$比例，并贡献自身颜色的$\alpha$比例来替代被阻挡的光线。






