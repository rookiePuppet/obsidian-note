
常用的编程范式有三种：面向过程、面向对象和函数式编程。面向对象已经过时，函数式编程并不能替代面向对象编程，只能用在一些特殊的业务领域，因此面向对象编程是目前流行的编程范式。

## 2.1 当我们再谈论面向对象时，到底在谈论什么

### 2.1.2 面向对象编程与面向对象编程语言

面向对象编程（OOP）中有两个基础且重要的概念：类和对象。

类和对象的概念最早出现在1960年，在Simula编程语言中第一次使用。面向对象编程的概念第一次被使用是在Smalltalk编程语言中，Smalltalk也被认为是第一个真正意义上的面向对象编程语言（OOPL）。

那么什么面向对象编程？什么样的编程语言才算是面向对象编程语言？如果一定要给出定义的话，那么可以用下面两句话来概括：

1. 面向对象编程是一种编程范式或编程风格，它以类和对象作为组织代码的基本单元，并将封装、抽象、继承和多态4种特性作为代码的设计和实现的基石。
2. 面向对象编程语言支持类或对象的语法机制，有现成的语法机制能方便地是实现面向对象编程的四大特性。

### 2.1.2 非严格定义的面向对象编程语言

如果不按严格的定义划分，大部分编程语言都是面向对象的编程语言。

例如JavaScript，其不支持封装和继承特性，按照上面严格的定义来说它并不是面向对象编程语言。

实际上，按简单、原始的方式理解，面向对象编程就是一种将对象或类作为代码组织的基本单元来进行编程的编程范式或风格。

没有必要非给面向对象编程语言下一个定义，以及争论某种编程语言是否为面向对象编程语言，这样做的意义不大。

### 2.1.3 面向对象分析和面向对象设计

面向对象编程不仅是一种编程风格，还可以是一种行为。

面向对象分析、面向对象设计和面向对象编程对应面向对象软件开发的三个阶段。

分析和设计这两个阶段的最终产出是类的设计，包括程序拆解为哪些类，每个类有哪些属性和方法，以及类之间如何交互等。

面向对象分析就是要弄清楚做什么，面向对象设计就是要弄清楚怎么做，面向对象编程就是将分析和设计的结果翻译成代码。

## 2.2 封装、抽象、继承和多态为何而生

### 2.2.1 封装

封装也称为信息隐藏或数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式来访问内部的信息或数据。

对于封装特性，需要编程语言提供一定的语法机制来支持，就是访问权限控制。

通过封装，可以保护类中的重要属性不被外部随意修改，同时类会向外提供有限的方法暴露必要的操作，使调用者不必清楚内部的细节就能够实现某个功能，以此提高类的易用性。

### 2.2.2 抽象

抽象是隐藏方法的内部实现，即调用者只需要关心方法提供什么功能，而不需要知道其如何实现。

在面向对象编程中，我们通常是借助编程语言提供的接口和抽象类这两种语法机制来实现抽象特性的。

实际上，函数本身就是一种抽象了。因为在调用函数时，只需要知道函数能做什么，不需要清楚它的实现细节，这也符合抽象的定义。

### 2.2.3 继承

继承用来表示类之间的is-a关系，如猫是一种哺乳动物。

从继承关系来讲，继承可以分为单继承和多继承。

为了实现继承特性，编程语言也需要提供特殊的语法机制。

继承特性很容易理解，也很容易使用。但是如果过度使用继承，即继承层次过深、过复杂，就会导致代码的可读性和可维护性变差。如果子类和父类高度耦合，那么修改父类的代码会直接影响子类。

继承是一个有争议的特性，很多人认为继承是一种反模式，应该少用甚至不用。

### 2.2.4 多态

多态是指在代码运行过程中，我们可以用子类替换父类，并调用子类的方法。

多态也需要编程语言提供相应的机制来实现：

1. 支持父类对象引用子类对象。
2. 支持继承。
3. 支持子类重写父类中的方法。

多态是很多设计模式、设计原则和编程技巧的代码实现的基础。

## 2.4 面向对象编程与面向过程编程和函数式编程之间的区别

### 2.4.1 面向过程编程

类比面向对象编程与面向对象编程语言的定义，面向过程编程和面向过程编程语言的定义如下：

1. 面向过程编程也是一种编程范式或编程风格，它以过程（方法、函数和操作）作为组织代码的基本单元，以数据（成员变量、属性）与方法相分离为主要特点。面向过程编程是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据实现一项功能。
2. 面向过程编程语言的主要特点是不支持类和对象的语法概念，不支持丰富的面向对象编程特性。

### 2.4.2 面向对象编程和面向过程编程的对比

相比面向过程编程，面向对象编程的优势如下：

1. 更适合大规模复杂程序的开发
2. 代码易复用、易扩展、易维护
3. 更加人性化、高级和智能

### 2.4.3 函数式编程

函数式编程中的函数并不是指编程语言中的函数，而是指数学中的函数或表达式。

面向对象编程最大的特点是以类、对象作为组织代码的单元以及它的四大特性，面向过程编程最大的特点是以函数作为组织代码的单元，数据与方法分离。

函数式编程独特的地方是它的编程思想，即程序可以用一系列数学函数或表达式的组合来表示，但是不是所有的程序都适合这样做。

函数式编程和面向过程编程一样是以函数作为组织代码的单元，不过区别在于，函数式编程的函数是无状态的。无状态就是说，函数的执行结果只跟输入的参数有关，与其他任何外部的变量无关，只要输入参数相同，函数的结果就相同。

## 2.5 哪些代码看似面向对象实则面向过程

### 2.5.1 滥用getter、setter方法

随意地为类中的每一个属性都定义getter、setter方法，违反了面向对象编程的封装特性，相当于使面向对象编程风格退化成面向过程编程风格。

在设计类时，除非必要，否则尽量不要给属性定义setter方法。尽管getter方法相对安全一些，但如果返回的是集合，也要防范集合内部数据被修改的风险。

### 2.5.2 滥用全局变量和全局方法

在面向对象编程中，常见的全局变量有单例类对象、静态成员变量和常量等，常见的全局方法有静态方法。静态方法将方法和数据分离，破坏了封装特性，是典型的面向过程编程风格。

### 2.5.3 定义数据和方法分离的类

还有一种在面向对象编程中常见的面向过程编程风格的代码：数据定义在一个类中，而方法定义在另一个类中。

传统MVC模式就是一种典型的面向过程编程风格，这种开发模式也被称为“贫血”模型的开发模式。

### 2.6 基于“贫血”模型的传统开发模式是否违背OOP

基于“贫血”模型的MVC三层架构开发模式虽然已经成为了标准的Web项目开发模式，但它违反了面向对象编程风格，因此被一些人称为“反模式”.

### 2.6.1 基于“贫血”模型的传统开发模式

MVC将整个项目分为3层：展示层、逻辑层和数据层。这是一种笼统的分层方式，落实到具体的开发层面，很多项目并不会完全遵从MVC固定的分层方式，而是根据具体的项目需求进行调整。

目前很多Web都是前后端分离的，后端负责暴露接口供前端调用。在这种情况下，我们一般将后端项目分为3层：Repository、Service和Controller。其中Repository层负责数据访问，Service层负责业务逻辑，Controller层负责暴露接口。

只包含数据，不包含业务逻辑的类，称为“贫血”模型。“贫血”模型将数据和操作分离，破坏了面向对象编程的封装特性，属于典型的面向对象编程风格。

### 2.6.2 基于“充血”模型的DDD开发模式

“充血”模型将数据和对应的业务逻辑封装在一个类中，因此它满足面向对象编程的封装特性，属于典型的面向对象编程风格。

领域驱动设计（DDD）主要用来指导如何解耦业务系统，划分业务模块，以及定义业务领域模型及其交互。

微服务除了用于监控、调用链追踪和API网关等服务治理系统的开发外，还有一个更加重要的工作，就是对公司的业务合理地进行服务划分。而领域驱动设计恰好是用来指导服务划分的，因此微服务加速了领域驱动设计的流行。

实际上基于“充血”模型的DDD开发模式也是按照MVC三层架构分层的，它与“贫血”型模式的主要区别在Service层。

### 2.6.3 两种开发模式的应用对比

### 2.6.4 基于“贫血”模型的传统开发模式被广泛应用的原因

1. 在大部分情况下，我们开发的系统业务比较简单，只包含基于SQL的CRUD操作，使用“充血”模型没有多大意义。
2. “充血”模型是面向对象编程风格的，开发难度相对更大。
3. 思维固化，转型有成本。

## 2.7 接口和抽象类：如何使用普通类模拟接口和抽象类

并不是所有比面向对象编程语言都支持接口和抽象类，但我们仍然可以通过一些手段模拟实现这两个语法概念。

### 2.7.1 抽象类和接口的定义与区别

> 抽象类

下面是一个典型的抽象类使用场景（模板设计模式）。

Logger是一个记录日志的抽象类，FileLogger类和MessageQueueLogger类继承Logger类，分别实现不同的日志记录方式：将日志输出到文件中和将日志输出到消息队列中。

```CSharp
public abstract class Logger
{
    private string _name;
    private bool _enabled;
    private Level _minPermittedLevel;

    public Logger(string name, bool enabled, Level minPermittedLevel)
    {
        _name = name;
        _enabled = enabled;
        _minPermittedLevel = minPermittedLevel;
    }

    public void Log(Level level, string message)
    {
        bool loggable = _enabled && (_minPermittedLevel <= level);
        if (!loggable) return;
        DoLog(level, message);
    }

    protected abstract void DoLog(Level level, string message);
}

// 抽象类的子类：输出到日志文件
public class FileLogger : Logger
{
    private FileStream _fileStream;

    public FileLogger(string name, bool enabled, Level minPermittedLevel, string filePath) : base(name, enabled,
        minPermittedLevel)
    {
        _fileStream = new FileStream(filePath, FileMode.Open);
    }

    protected override void DoLog(Level level, string message)
    {
        // 格式化level和message，并输出到日志文件
    }
}

// 抽象类的子类：输出日志到消息中间件
public class MessageQueueLogger : Logger
{
    private MessageQueueClient _msgQueueClient;

    public MessageQueueLogger(string name, bool enabled, Level minPermittedLevel, MessageQueueClient msgQueueClient) :
        base(name, enabled, minPermittedLevel)
    {
        _msgQueueClient = msgQueueClient;
    }

    protected override void DoLog(Level level, string message)
    {
        // 格式化level和message，并输出到消息中间件
    }
}
```

总结抽象类的特点：

1. 抽象类不能实例化，只能被继承。
2. 抽象类可以包含属性和方法。方法可以包含或不包含代码实现，不包含代码实现的方法称为抽象方法。
3. 继承抽象类必须实现所有抽象方法。

> 接口

总结接口的特点：

1. 接口不能包含属性（成员变量）。
2. 接口只能声明方法，不能实现。
3. 实现接口时，必须实现接口中所有的方法。

```CSharp
public interface Filter
{
    void DoFilter(RpcRequest request);
}

// 接口实现类：鉴权过滤器
public class AuthencationFilter : Filter
{
    public void DoFilter(RpcRequest request)
    {
        // 鉴权逻辑
    }
}

// 接口实现类：限流过滤器
public class RateLimitFilter : Filter
{
    public void DoFilter(RpcRequest request)
    {
        // 限流逻辑
    }
}

// 过滤器使用示例
public class Application
{
    private List<Filter> _filters = new();

    public Application()
    {
        _filters.Add(new AuthencationFilter());
        _filters.Add(new RateLimitFilter());
    }

    public void HandleRpcRequest(RpcRequest request)
    {
        foreach (var filter in _filters)
        {
            filter.DoFilter(request);
        }
    }
}
```

### 2.7.2 抽象类和接口存在的意义

抽象类是为代码复用而生的，多个子类可以继承抽象类中定义的属性和方法，避免在子类中编写重复的代码。

接口是对行为的抽象，相当于一组协议或契约，其侧重于解耦。调用者只需要关注抽象的接口，不需要了解具体的实现。接口实现了约定和实现分离，可以降低代码的耦合度，提高代码的可扩展性。

### 2.7.3 模拟实现抽象类和接口

C++中只有抽象类，没有接口，但可以使用抽象类模拟接口。

```CPP
class Strategy {
public:
	virtual ~Strategy();
	virtual void algorithm() = 0;
	
protected:
	Strategy();
};
```

Python中不但没有抽象类，也没有接口，这种情况可以使用普通类模拟接口。

```Java
public class MockInterface {
	protected MockInterface() {}
	
	public void FuncA() {
		throw new MethodUnSupportedException();
	}
}
```

类中的方法必须包含实现，这不符合接口的定义。所以我们让类中的方法抛出异常来模拟不包含实现的接口，在子类继承父类时强制子类主动实现父类的方法。

为了避免这个类被实例化，还要将构造函数声明成protected。

### 2.7.4 抽象类和接口的应用场景

在实际项目开发中，什么时候该用抽象类？什么时候该用接口？

如果我们要表示一种is-a关系，并且是为了解决代码复用的问题，就使用抽象类。

如果我们要表示一种has-a关系，并且是为了解决抽象而非代码复用的问题，就使用接口。

从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，再抽象出上层的父类。而接口正好相反，它是一种自上而下的设计思路，在编程开发时，一般先设计接口，在考虑具体实现。