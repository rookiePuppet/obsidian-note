# 2.1 数组（上）：为什么数组的下标一般从0开始编号

## 2.1.1 数组的定义

**数组**是一种**线性表**数据结构，它用一组**连续的内存空间**存储一组具有**相同类型的数据**。数组具有随机访问的特性。

## 2.1.2 寻址公式和随机访问特性

随机访问指的是：支持在$O(1)$的时间复杂度内按照下标快速访问数组中的元素。

当计算机给数组分配了一段连续的内存空间，可以知道这段内存空间的首地址，如果要访问任意下标的数组元素，那么就可以根据首地址以及数据单元所占的字节大小来计算出目标元素的地址，公式为
$$
a[i]\_address=base\_address+i\times data\_type\_size
$$
对于**数组和链表的区别**，这种表述是不准确的：链表适合插入、删除，对应的时间复杂度为$O(1)$；数组适合查找，查找的时间复杂度为$O(1)$。

在数组中查找数据的时间复杂度并不是$O(1)$。即便是排好序的数组，使用二分查找，时间复杂度也只能达到$O(logn)$。

因此正确的表述应该是：数组支持随机访问，根据下标访问元素的时间复杂度为$O(1)$。

## 2.1.3 低效的插入和删除操作

为了保持内存数据的连续性，数组的插入和删除操作会比较低效。

假设一个数组长度为n，若要将一个数据插入到第k个位置上，并保持原顺序，则需要先将第k~n个元素顺序地向后移动一位，平均时间复杂度为$O(n)$。

如果数组中的数据是没有规律的，那么可以直接将第k位元素移动到数组的末尾，再将新数据插入到第k位上。

如果是删除第k个元素，为了保持数据的连续性，也是需要将后面的数据往前搬移。

而在某些特殊情景下，不一定要保持数据的连续性，我们可以将多次删除操作集中在一起执行，删除的效率就会高很多。例如数组中存储了8个元素分别是：$a,b,c,d,e,f,g,h$，我们要依次删除$a、b、c$三个元素，为了避免数据的多次搬移，每次删除操作并不是真正地将数据移除，而是对其做删除标记，最后在集中执行一次真正的删除操作，并且做数据的搬移。这其实就是JVM垃圾回收算法的核心思想了。

## 2.1.4 警惕数组访问越界问题

```C++
int main(int argc, char* argv[]) {
    int i = 0;
    int a[3] = {0};
    for(; i <= 3; i++) {
        a[i] = 0;
        printf("hello world\n")；
    }
    return 0;
}
```

这段代码的运行结果并非是输出三行"hello world"，而是无限循环输出"hello world"。

因为这段代码中有一个错误，数组大小为3，for循环的结束条件应该是$i<3$而不是$i<=3$。当i=3时，数组访问就越界了。

a\[3]定位到不属于数组a的内存地址上，而这个地址如果恰好是变量i的地址，那么$a[3]=0$就相当于$i=0$，就这样导致了无限的循环。

## 2.1.5 容器能否完全替代数组

> 针对数组类型，很多编程语言都提供了容器类，如Java中的ArrayList，C++ STL中的vector。

ArrayList最大的优势在于它将很多数组操作的细节封装了起来，可以很方便地调用。另外，它支持动态扩容，如果预分配的内存空间不够，它会自动地再分配新的内存空间。

下面的情况中使用数组会更加合适：

- ArrayList无法存储基本数据类型，如int需要封装为Integer类，然而自动装箱和拆箱有一定的内存消耗。如果特别注重性能或要使用基本数据类型，最好使用数组。

- 如果数据大小已知，并且对数组的操作非常简单，用不到ArrayList提供的大部分方法，那么就可以直接使用数组。

- 表示多维数组时，数组的定义会更加直观，可读性更高。

## 2.1.6 解答开篇的问题

如果数组下标从1开始编号，在计算偏移时会多出一次减法计算，无法将性能做到极致。

还有就是C语言的设计者用0作为数组的下标，目的是在一定程度上减少C语言程序员学习其他编程语言的成本。

# 2.2 数组（下）：数据结构中的数组和编程语言中的数组的区别

> 在大部分数据结构和算法的图书中，对于二维数组或多维数组中数据的存储方式一般是这样介绍的：二维数组中的数据以"先按行，再按列"（或"先按列，再按行"）的方式依次存储在连续的存储空间中。但是在有些编程语言中，二维数组并不满足上面的定义，例如Java中的二维数组的第二维可以是不同长度的。

## 2.2.1 C/C++中数组的实现方式

- C++中的数组完全符合数据结构中数组的标准定义，利用一块连续的内存空间存储相同类型的数据。

- C/C++语言中基本数据类型数组、对象（结构体）数组以及二维数组，它们的数据存储格式完全符合数据结构中对数组的定义。

## 2.2.2 Java中数组的实现方式

- 基本数据类型数组符合数据结构中数组的定义，数组中的数据都是相同类型的，并且存储在连续的内存空间中。
- 对象数组中存储的是对象在内存中的地址，而非对象本身，对象在内存中并不是连续存储的。
- 多维数组与二维数组类似，二维数组中的第二维可以是不同长度的，不符合数据结构中对数组的定义。

## 2.2.3 JavaScript中数组的实现方式

- JavaScript中的数组可以存储不同的类型的数据，并且数据不一定是连续存储的，支持变长数组，完全与数据结构中的定义相反。
- JavaScript中的数组会根据存储数据的不同，选择不同的实现方式。
	- 如果数组中存储的是相同类型的数据，JavaScript会分配一块连续的内存空间来存储。
	- 如果数组中存储的是不相同类型的数据，JavaScript就会用类似哈希表的结构来存储数据，也就是说数据在内存中并不是连续存储的。
- JavaScript提供了ArrayBuffer这种数据类型，其完全符合数据结构中数组的定义。

# 2.3 链表（上）：如何基于链表实现LRU缓存淘汰算法

## 2.3.1 链表的底层存储结构

链表与数组的存储结构完全不同，其不需要一块连续的内存空间，而是通过"指针"将一组连续的内存块串联起来使用。

## 2.3.2 链表的定义和操作

在链表中，为了将所有节点串联起来，每个节点除存储数据本身之外，还需要额外存储下一个节点的地址。

两个特殊的节点：头节点记录链表的基地址，从头节点开始可以遍历整个链表；尾节点是链表的最后一个节点，其next指针指向空地址null。

用Java代码定义链表：

```java
public class LinkedList {
    public class Node {
        public int data;
        public Node next;
    }
    private Node head = null;
}
```

在链表中插入和删除数据相比数据更加高效，时间复杂度为$O(1)$。需要注意的是，这里的删除操作能实现$O(1)$的时间复杂度，是因为已知前驱节点的前提下

```java
//查找值为value的节点
public Node find(int value) {
    Node p = head;
    while(p != null && p.data != value) {
        p = p.next;
    }
    return p;
}

//在节点b后插入节点x
public void insert(Node b, Node x) {
    if(b == null) {
        x.next = head;
        head = x;
    } else {
        x.next = b.next;
        b.next = x;
    }
}

//已知前驱节点a的情况下删除节点b
void remove(Node a, Node b) {
    if(a == null) {
        head = head.next;
    } else {
        a.next = a.next.next;
    }
}
```

在数组中查找第k个元素可以直接通过首地址和下标来计算出目标地址，然而在链表中则需要从头节点开始，依次遍历直到第k个节点为止，时间复杂度为$O(n)$。

```java
public Node get(int k) {
    Node p = head;
    int i = 0;
    while(p != null && i != k) {
        i++;
        p = p.next;
    }
    return p;
}
```

## 2.3.3 链表的变形结构

### 循环链表

循环链表与单链表唯一的区别在于尾节点。单链表的尾节点的next指针指向空地址，而循环链表的尾节点的next指针指向链表的头节点。

和单链表相比，循环链表的优点就是从链尾遍历到链头比较方便。当要处理的数据具有环形结构特征时，就特别适合采用循环链表。

### 双向链表

双向链表支持两个遍历方向，每个节点不只有next指针，还有prev指针，用来指向其前面的节点。

定义双向链表的Java代码如下：

```java
public class DoublyLinkedlist {
    public class Node {
        public int data;
        public Node prev;
        public Node next;
    }
    public Node head = null;
}
```

可以看出，存储同样多的数据，双向链表比单链表要占用更多内存空间。不过这样，双向链表可以在$O(1)$的时间复杂度下找到某个节点的前驱节点，使得其插入、删除等操作要比单链表更简单高效。

以删除操作为例。对于删除某个特定值节点的情况，双向链表和单链表都需要先从头节点遍历直到找到目标节点，时间复杂度都为$O(n)$。对于删除某个已知节点的情况，虽然已经知道要删除的节点，但还需要知道其前驱节点，单链表需要从头遍历找到前驱节点，时间复杂度为$O(n)$，而双向链表的节点中已经保存了前驱节点的指针，不需要遍历搜索，时间复杂度为$O(1)$。

同理，在某个节点前插入一个节点，双向链表也比单链表更高效。

双向链表虽然占用更多内存，但比单链表的应用更广泛。如Java中的LinkedHashMap就用到了双向链表。

### 2.3.4 链表与数组的性能对比

数组和链表的对比并不能局限于时间复杂度的对比，在实际的软件开发中，不能只根据时间复杂度就决定数据该选择哪种数据结构来存储，还需要考虑其他方面的的因素。

数组使用连续的存储空间来存储数据，我们可以有效地利用CPU的缓存机制，预读数组中的数据，提高访问效率。而链表在内存中并不是连续存储的，因此没办法预读，对CPU缓存不友好。

数组的缺点是大小固定，一经声明就要占用整块连续的内存空间。如果声明的空间过大，系统可能没有足够的连续内存空间来分配，就会抛出内存不足的异常。如果声明的空间过小，

# 2.4 链表（下）：借助哪些技巧可以轻松地编写链表相关的复杂代码

## 2.4.1 技巧1：理解指针或引用的含义

有些语言如C、C++中会有指针的概念，而另一些语言如Java、Python中没有，取而代之的是引用这个概念。指针和引用表达的含义都是一样的，存储的都是所指或所引用对象的内存地址。

## 2.4.2 技巧2：警惕指针丢失和内存泄漏

以单链表的插入操作为例，在节点a和相邻的节点b之间插入节点x，如果实现的代码是这样的，那么就会发生指针丢失和内存泄露的问题。

```java
a.next = x;
x.next = a.next;
```

在第一行代码执行完后，节点a的next指针指向节点x，第二行代码实际上就是把x的next指针指向自己。这样一来，节点b之后的节点都无法访问到了。因此在插入节点时，一定要注意操作的顺序，先将节点b赋值给节点x的next指针，在将节点a指向节点x。

对于某些语言，需要程序员来管理内存，对于被删除的节点，如果没有调用释放内存的函数来释放节点占用的内存空间，内存就无法被系统回收，其他程序就无法使用，就会产生内存泄漏。对于像Java这种使用虚拟机自动管理内存的语言就不需要程序员手动释放内存。

## 2.4.3 技巧3：利用"哨兵"简化代码

假设现在要实现一个在链尾插入数据的函数，为了提高插入效率，我们用tail来记录当前的链尾节点，Java代码如下。

```java
public class LinkedList {
    public class Node {
        public int data;
        public Node next;
    }
    private Node head = null;
    private Node tail = null;
    
    public void insertAtTail(Node newNode) {
        tail.next = newNode;
        tail= newNode;
    }
}
```

但是如果当前链表是空链表，上面的代码逻辑就不正确了。我们还需要对向空链表中插入第一个节点这种特殊情况进行处理，代码如下。

```java
public void insertAtTail(Node newNode) {
    if(head == null) {
        head = newNode;
        tail = newNode;
        return;
    }
    tail.next = newNode;
    tail = newNode;
}
```

从这个例子可以看出，向空链表和非空链表中插入数据的逻辑是不一样的，这样使代码变得烦琐，而且容易忘记处理特殊情况。可以使用"哨兵"来解决这个问题。

在引入哨兵之前，对于空链表，head和tail都是null。引入哨兵之后，无论链表是否为空，head和tail都不为null。

把有哨兵节点的链表称为带头链表，无哨兵节点的链表称为不带头链表。带头链表代码如下。

```java
public class LinkedList {
    public class Node {
        public int data;
        public Node next;
    }
    public Node head = null;
    public Node tail = null;
    
    public LinkedList() {
        Node guard = new Node();
        head = guard;
        tail = guard;
    }
    
    public void insertAtTail(Node newNode) {
        tail.next = newNode;
        tail = newNode;
    }
}
```

## 2.4.4 技巧4：留意边界条件和特殊情况

在实际的软件开发中，代码中的bug往往是由对边界条件或特殊情况处理不全或不当而产生的，我们一定要在编写过程中或编写完成后，检查边界条件和特殊情况是否考虑全面。下面是经常用来检查链表的实现代码是否正确的边界条件或特殊情况。

- 如果链表为空时，代码是否能正常工作？
- 如果链表只包含一个节点，代码是否能正常工作？
- 如果链表只包含两个节点，代码是否能正常工作？
- 如果要处理的节点是特殊节点，代码是否能正常工作？

## 2.4.5 技巧5：举例画图，辅助思考

针对复杂的链表问题，可以找一个具体的例子，画在纸上，然后看图思考解决方法。

## 2.4.6 技巧6：多写多练，没有捷径

常见的链表操作：

- 单链表反转
- 链表中环的检测
- 两个有序的链表合并
- 删除链表倒数第k个节点
- 寻找链表的中间节点

# 2.5 栈：如何实现浏览器的前进和后退功能

## 2.5.1 栈的定义

典型的栈结构：后进先出，先进后出。

特定的数据结构是对特定场景的抽象。

数组和链表暴露了太多的操作结构，操作上灵活自由，但使用起来相对不可控，容易出错。当某个数据集合只涉及一端插入数据和删除数据，并且满足后进先出、先进后出的特性时，就应该首选"栈"这种数据结构。

## 2.5.2 顺序栈和链式栈

栈既可以用数组实现，也可以用链表实现。

用数组实现的栈称为顺序栈，用链表实现的栈称为链式栈。

基于数组实现的顺序栈代码如下。

```java
public class ArrayStack {
    private String[] items; //数组
    private int count; //元素个数
    private int n; //栈的大小
    
    public ArrayStack(int n) {
        this.items = new String[n];
        this.count = 0;
        this.n = n;
    }
    
    public boolean push(String item) {
        if(count == n) return false; //数组空间不够，入栈失败
        //将item放到下标为count的位置，并且count+1
        item[count] = item;
        ++count;
        return true;
    }
    
    public String pop() {
        if(count == 0) return null; //栈为空，返回null
        //返回下标为count-1的元素，并且栈中元素个数count-1
        String tmp = items[count-1];
        --count;
        return tmp;
    }
}
```

无论是顺序栈还是链式栈，在入栈和出栈的过程中，只需要申请一两个临时变量，因此空间复杂度是$O(1)$。

无论是顺序栈还是链式栈，入栈和出栈只涉及栈顶数据的操作，因此时间复杂度是$O(1)$。

## 2.5.3 支持动态扩容的顺序栈

如果要实现一个支持动态扩容的顺序栈，只需要底层依赖一个支持动态扩容的数组。当栈满之后，就申请一个更大的数组，将原来的数据搬移到新的数组中。

出栈不会涉及内存的重新申请和数据搬移，因此时间复杂度为$O(1)$。

对于入栈，当栈中有未占用空间时，时间复杂度为$O(1)$。当栈中没有为占用空间时，对应的时间复杂度为$O(n)$。

入栈操作的平均时间复杂度使用摊还法进行分析，先做如下假设：

- 当栈空间不够时，重新申请一个大小为原来2倍的数组。
- 为了简化分析，假设只有入栈操作，没有出栈操作。
- 将不涉及内存搬移的入栈操作定义为simple-push操作，时间复杂度为$O(1)$。

若当前栈的大小为K，且已满，当新数据入栈时，我们就需要重新申请一个大小为2K的数据，并做K个数据搬移操作，然后将新数据入栈，时间复杂度为$O(K)$。

接下来的K-1次入栈操作都不需要重新申请内存和搬移数据了，因此这K-1次操作都分别只需要一个simple-push操作来完成。

将K个数据搬移均摊到K次入栈操作，每个入栈操作只需要进行一次数据搬移和一个simple-push操作。

因此，入栈操作的均摊时间复杂度为$O(1)$。

## 2.5.4 栈在函数调用中的应用

操作系统给每一个线程分配了一块独立的内存空间，这块内存被组织成"栈"这个结构，用来存储函数调用时的临时变量。在函数调用过程中，每调用一个新的函数，编译器就会将被调用函数的临时变量封装成栈帧并压入栈中，当被调用函数执行完成并返回后，编译器就将这个函数对应的栈帧弹出栈。

## 2.5.5 栈在表达式求值中的应用

假设表达式求值只包括加减乘除运算。

编辑器通过两个栈来实现表达式的求值，其中一个栈用来保存操作数，另一个栈用来保存操作符。 

从左至右遍历表达式，遇到数字时，就将其压入操作数栈，遇到操作符时，就将其与操作符栈顶元素进行比较，若栈顶优先级低，则将操作符入栈，若栈顶优先级高，则从操作符栈中取出栈顶元素，再从操作数栈中取出两个操作数进行计算，计算结果再压入操作数栈中，以此循环。

## 2.5.6 栈在括号匹配中的应用

假设表达式中只有3种括号：圆括号，方括号和花括号，并且它们可以任意嵌套。我们可以用栈来检查一个表达式字符串是否合法。

用栈来保存未匹配的左括号，从左至右依次扫描字符串。扫描到左括号时，将其压入栈种，扫描到右括号时，则从栈顶取出一个左括号进行比较，若匹配则将左括号出栈，再继续扫描剩余字符串。在扫描过程中，若遇到不能匹配的右括号，或栈中没有可匹配的数据，则说明该表达式非法。

当所有字符扫描完成，若栈为空，说明表达式合法；若栈不为空，则说明表达式非法。

## 2.5.7 解答开篇问题

- 使用两个栈X和Y。
- 先把首次浏览的页面依次压入栈X。
- 点击后退时，从X中取出数据压入Y。
- 点击前进时，从Y中取出数据压入X。

# 2.6 队列：如何实现线程池等有限资源池的请求排队功能

## 2.6.1 队列的定义

先进先出是队列的最大特点。

队列的应用广泛，特别是一些具有高级特性的队列，如循环队列、阻塞队列和并发队列，在很多偏底层的系统、框架、中间件的开发中，起到关键性作用。

## 2.6.2 顺序队列和链式队列

基于数组实现的队列称作顺序队列，基于链表实现的队列称作链式队列。

顺序队列的实现代码如下。

```java
public class ArrrayQueue {
    private String[] items;
    priavte int n = 0;
    private int head = 0;
    private int tail = 0;
    
    public ArrayQueue(int capacity) {
        item = new String[capacity];
        n = capacity;
    }
    
    public boolean enqueue(String item) {
        if(tail == n) return false;
        items[tail] = item;
        ++tail;
        return true;
    }
    
    public String dequeue() {
        if(head == tail) return tail;
        String ret = items[head];
        ++head;
        return ret;
    }
}
```

因为队列的入队操作发生在队尾，出队操作发生在队头，所以需要两个指针分别指向队尾和队头。

随着不断有数据入队和出队，head和tail指针持续向后移动。当tail指针移动到数组最右边时，即便数据还有未占用的空间，也无法继续添加数据了。

我们可以在tail指针移动到最右边后，并且有新数据要入队时，进行一次数据搬移操作，将head指针到tail指针的数据整体搬移到数组从0开始的位置。

改造入队函数的代码如下。

```java
public boolean enqueue(String item) {
    if(tail == n) {
        if(head == 0) return false;
        for(int i = head; i < tail; ++i) {
            items[i-head] = items[i];
        }
        tail -= head;
        head = 0;
    }
    items[tail] = item;
    ++tail;
    return true;
}
```

## 2.6.3 循环队列

循环队列避免了在`tail==n`时的数据搬移操作。

编写循环队列的关键是确定队列空和队列满的判定条件。

对于非循环队列，队列满的判定条件是$tail==n$，队列空的判定条件是$head==tail$。

对于循环队列，队列空的判定条件依然是$head==tail$，而队列满的判定条件就不一样了，根据画图举例分析可以得到循环队列满时的一个条件：$(tail+1)\%n==head$。

为了区分队列空和队列满的判定条件，循环队列中的tail指针指向的位置是不存储数据的，也就是说循环队列会浪费一个存储空间，代码如下。

```java
public class CircularQueue {
    private String items[];
    private int n;
    private int head = 0;
    private int tail = 0;
    
    public CircularQueue(int capacity) {
        items = new String[capacity];
        n = capacity;
    }
    
    public boolean enqueue(String item) {
        if((tail+1)%n==head) return false;
        items[tail] = item;
        tail = (tail + 1) % n;
        return false;
    }
    
    public String dequeue() {
        if(head == tail) return null;
        String ret = items[head];
        head = (head+1)%n;
        return ret;
    }
}
```

## 2.6.4 阻塞队列和并发队列

**阻塞队列**就是在队列的基础上增加了阻塞特性。当队列为空时，从队头取数据会被阻塞，直到队列中有数据时才返回；当队列已满时，插入数据会被阻塞，直到队列中有空闲位置后再插入数据，然后返回。

在多线程的情况下，多个线程同时操作队列，就会存在线程安全问题，如何实现一个线程安全的队列呢？

线程安全的队列又称并发队列。最简单的实现方式是直接在enqueue和dequeue函数上加锁，但这会导致同一时刻仅允许一个存或取操作，锁粒度太大会导致并发度太低。实际上，基于数组的循环队列，利用CAS原子操作，可以实现非常高效的无锁并发队列。
