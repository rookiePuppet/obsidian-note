# 为什么使用Addressables

## 什么是动态资产管理

动态资产管理系统让你可以在运行时决定何时以及从何处加载资产到内存，以提高游戏性能。

Addressables系统被设计用于取代和改进历史遗留的或不足以满足现有需求的资产管理方式。

### 直接引用

当把一个资产拖拽进场景或组件时，就是在直接引用该资产。

当构建应用时，这些资产会被保存到与场景相关联的一个单独文件中。当游戏运行在用户设备上，Unity会在场景被加载之前将整个资产文件加载到内存中，以确保场景可以访问到其直接引用的资产。

直接引用的资产管理方式不是动态的，加载与卸载场景是你对资产仅有的控制。这还会导致游戏构建结果非常大，在低内存设备上运行会非常缓慢。

### Resources文件夹

Resources文件夹和Resources API提供了一种管理内存中的资产的简单方式。

在构建期间，编辑器会查找所有名为Resources的文件夹中的资产，然后将它们打包成一个带有元数据和索引信息的序列化文件，并整合到应用程序中。

使用Resources系统不能对内存管理进行精细的控制，而且还会增大构建体积并减慢启动时间，也不支持通过CDN进行内容分发。

### AssetBundle系统

AssetBundle系统将资产组织进一种叫做AssetBundles的容器，就像Resources文件夹一样，它将资产集合创建为单独的文件，不同的是，AssetBundles可以存储在玩家本地或者云端远程。

AssetBundle系统允许你只下载需要的资产包，因此你可以增加DLC和预发布内容更新。当包下载完成，就使用AssetBundles API从包中加载或卸载资产。

虽然它完全是针对特定需求定制的系统，但也有一些局限，需要开发者实现他们自己的解决方案：

- AssetBundles API只能在脚本中使用，Unity编辑器中对于定义AssetBundles的用户界面十分有限，而构建AssetBundle需要使用脚本。
- AssetBundles API本身不会处理包与包之间的资产依赖。例如，从包A中加载一个预制体时，你需要定位其所有的依赖（可能位于其他包中的网格、材质、纹理等等），确保依赖的包在运行时加载到内存之后，才能加载预制体。
- 内存分配和释放是直接和手动的。当从包中卸载一个资产时，其他地方仍在依赖该资产，这可能导致内容丢失和内存泄漏问题。
- AssetBundles运行时API并不了解资源是放置在本地还是远端的，需要你手动追踪AssetBundle的位置。

### Addressables

Addressables系统是在AssetBundles API基础之上构建的，提供了编辑器界面，将之前只能手动编写脚本来管理资产的过程自动化。

Addressables系统能自动处理依赖，资产位置和内存分配释放问题。

## 为什么应该使用Addressables

**可寻址**的资产拥有一个能够在脚本中引用的地址，而不是资产文件名或包的位置。地址使Addressables能够自动化处理大量的细节。

### 灵活性

资产可以和应用程序一起存放于硬盘中，或者从远端服务器请求下载。你可以改变某一个资产的存放位置，例如从本地移动到远端，或者从一个大包分离到更小的包，并且无需代码。

### 依赖管理

Addressables会在你加载资源时自动加载所有的依赖。

### 内存管理

Addressables系统在加载和卸载资产时，会追踪内存的分配，将大部分枯燥的内存管理工作自动化。

### 高效内容打包

Addressables系统能够建立复杂的依赖关系链，使打包资产过程十分高效。你可以选择资产分布的颗粒度，轻松地为本地以及支持按需下载的远端分发或DLC做准备，以减小应用体积。

### 云构建和内容分发

Addressables系统已经集成进Unity Gaming Services，特别是Cloud Content Delivery和 Cloud Build，提供在线游戏更新和云构建的端到端服务。

### 脚本化构建管线

Addressables系统使用Scriptable Build Pipeline（SBP），比遗留的AssetBundle构建管线更加稳定。你可以使用预定义的构建流，也可以使用拆分的API进行自定义。

### 本地化

Addressables系统还集成了Unity的本地化包，从而能在项目中使用多种语言。