# URP中的灯光

## 渲染器的选择

URP提供了不同的渲染技术，每一种都有其优势和缺陷，如何选择这些渲染技术取决于项目的特定需求和限制。

|          | 原理                                                                                | 优点                                                          | 缺点                                                         |
| -------- | --------------------------------------------------------------------------------- | ----------------------------------------------------------- | ---------------------------------------------------------- |
| Forward  | 场景中的物体被逐一渲染，每一个像素单独计算。这意味着对于屏幕上的每一个像素，Unity都要对场景中的每一个对象计算光照和着色，以确定它们对像素最终颜色的贡献。   | 流程相对直接，易于理解，在光源较少和材质简单的场景中表现好。                              | 由于需要为场景中每一个光源使用多个通道处理，在面对大量光源和复杂材质的场景时可能比较低效。              |
| Forward+ | 将光源分组为集群，只有处于集群当中的物体才被纳入光照计算，而不是对所有物体逐一处理每一个光源。                                   | 相比于Forward渲染，尤其在大量光源的场景下有更好的性能，能通过减少需要计算光照的物体数量来更高效地利用硬件资源。 | 在极端大量光源和复杂场景下可能仍然表现不佳，并且要实现Forward+渲染需要做更多的优化工作。           |
| Deferred | 将光照和着色计算从几何渲染过程中解耦出来。首先将几何渲染到一个缓冲区集合（包含每一个像素的位置、法线和材质属性等信息）中，然后根据缓冲区数据进行逐像素的光照计算。 | 对于渲染大量光源或复杂材质的场景非常高效，因为光照是逐像素而不是逐对象计算的。                     | 由于需要存储额外的缓冲区，内存占用会增加。对透明物体的渲染有限制，以及在处理特定类型的光照效果时有困难（如体积光）。 |
## 用于光照场景的URP着色器

| Shader      | 描述                                                                                                              |
| ----------- | --------------------------------------------------------------------------------------------------------------- |
| Lit         | 以写实质量渲染真实世界中的表面，在各种光照条件下都能获得逼真的光影和反射效果。支持烘焙、混合以及实时光照，是大多数支持光照的材质的默认选项。使用的是基于物理的着色模型，由于其着色计算的复杂性，最好避免在低端移动设备上使用。 |
| Simple Lit  | 使用非能量守恒的Blinn-Phong着色模型，更适合非基于物理着色的项目以及低端移动设备。                                                                  |
| Complex Lit | 拥有Lit的所有特性，会计算两次高光反射（基础层和位于基础层之上的模拟的一层透明薄层）。当需要使用清漆选项实现汽车的金属光泽时，选择该着色器。                                         |
| Baked Lit   | 对于不需要实时光照的对象，例如永远不会受动态物体、实时光源和动态阴影影响的远处静态物体，使用该着色器可提高性能。                                                        |
## 照亮新场景

在URP中照亮一个新场景的第一步是创建一个新的光照设置资产，通过切换光照设置资产可以在不同光照设置之间切换。

## 环境光照

最主要的环境光是在Lighting面板中的Environment页签下配置的。

可以使用场景天空盒，设置强度、渐变或颜色来设置环境光照。Skybox模式要求按需烘焙来计算天空的环境探针，只有Gradient和Color模式会实时更新。

## 阴影

### 主光源阴影分辨率

实时阴影需要渲染一张包含光源视角的物体深度数据的阴影纹理，阴影纹理的分辨率越高，阴影的视觉保真度就越高，当然也需要更多的算力和内存。影响阴影计算的因素包括：

1. 渲染在阴影纹理中的阴影投射器数量，对于主光源，该数量取决于阴影距离（URP资产Shadows模块的Max Distance）
2. 可见的阴影接收者
3. 阴影级联分段（Shadow Cascades splits）
4. 阴影过滤（软阴影）

> [!NOTE] 阴影级联
> 方向光在摄像机附近产生的实时阴影会出现像素化的问题叫做透视走样，阴影级联可以解决该问题。

最高分辨率得到的效果并不总是最理想的，例如使用软阴影时，阴影贴图会被模糊，使用高分辨率的阴影贴图会导致阴影边缘过于清晰，得不到模糊效果。

### 主光源阴影最大距离

最大距离的单位和场景单位一样，当最大距离设置太大时，阴影贴图会分散在过大的区域，导致镜头内部分的贴图分辨率远低于需求。

最大距离需要根据玩家所能看到物体的最远距离来设置，也就是说如果玩家最远只能看到离摄像机60单位的阴影，那就将该数值设置为60。

当混合光源的光照模式设置为Shadowmask时，超出阴影最大距离的物体的阴影会被烘焙，只有动态阴影才会被最大距离限制。

### 阴影级联

物体由于透视消失在远处，可以降低远距离视野的阴影分辨率，将更多的资源用于处理靠近摄像机的阴影，这就是阴影级联的核心思想。

该技术的原理是将原来的单张阴影贴图拆分为多张贴图，拆分的逻辑是根据摄像机视锥体深度划分多个层次进行分割。每张级联贴图的覆盖范围和尺寸都不同，距离越近的贴图覆盖范围和尺寸越小，主要为近处物体提供更好的细节，距离越远的贴图覆盖范围和尺寸大，阴影相对模糊，因为远处阴影不需要细节（看不清）。相邻的级联之间会进行混合，以实现平滑过渡。

对于小场景，一个级联就可达到最佳效果。如果阴影最大距离非常大，那就需要两到三个级联。

### 附加光源阴影

附加光源只在其模式设置为逐像素（Per Vertex）时，才会投射阴影。

阴影图集（Shadow Atlas）是一张组合了所有光源（能投射阴影）的阴影贴图的纹理，由于点光源需要在任何方向上投射阴影，一个点光源会投射六张阴影贴图，创建出一个立方体贴图，这就造成了点光源对性能需求是最高的。

附加光源在不同层次投射阴影的分辨率可通过Shadow Resolution tiers设置。

### 灯光模式

一般场景中静态的几何体占大多数，所以对于一个静态的光源，我们不需要实时重复地为其计算光照和阴影，只需要在开发时计算一次，在渲染时直接使用预先计算好的数据即可，这种方法叫做光照贴图映射或烘焙。

要将几何体纳入光照映射，需要在GameObject Inspector中勾选Static。

光照映射相关设置位于Lighting窗口的Scene部分，对于光照贴图的分辨率，应更尽可能小，另外可以选择Progressive GPU来加速光照贴图的生成。

Filtering会对贴图进行模糊来使噪声最小化，但是可能会导致两个物体阴影相交的地方产生缝隙，使用A-Trous滤波可以最小化这种误差。

当使用Mixed模式的灯光时，可以在Lighting窗口中将光照模式设置为以下三种：

- Baked Indirect：仅间接光会烘焙到光照贴图和光照探针，直接光和阴影是实时的。该模式非常消耗性能，不适合用于移动端。
- Subtractive：将来自Mixed模式方向光的直接光烘焙到静态几何，然后减去动态几何投射的阴影。这种模式会导致静态几何无法向动态物体投射阴影，除非使用了光照探针或自适应探针体积（ADV）。URP会对方向光的光照值进行估算，然后从全局光照烘焙中减去估值，最终的光照颜色会受到Real-time Shadow Color设置的约束。该模式是最适合低端设备的选项，但是不能将烘焙阴影和实时阴影进行结合，导致视觉瑕疵。
- Shadowmask：和Baked Indirect模式一样会结合动态和烘焙阴影，在远处也能正常渲染阴影。该模式会使用一张额外的阴影遮罩纹理，将额外信息存储在光照探针中，这能提供最高的阴影保真度，但也是最消耗性能和内存的。视觉上与Backed Indirect模式的差距在视野远处才会明显，这很适合开放世界场景，只推荐中高端设备使用。

在Mesh Renderer组件的Lightmapping中，可以调节Scale In Lightmap参数，让远处物体在光照贴图中占据更少的空间。

最后点击Lighting窗口中的Generate Lighting即可开始烘焙。烘焙时间取决于静态物体的数量，Mixed和Baked模式灯光的数量，以及光照贴图分辨率、最大光照贴图尺寸等设置，另外烘焙时间是和烘焙中使用的射线数量成正比的。

## 渲染层级

利用渲染层级可以特定的游戏物体只受特定的灯光影响，从而在场景中强调突出它们。

设置渲染层级的步骤：

1. 在URP资产的Lighting部分，点击三点图标，选择Advanced Properties，开启Use Rendering Layers。
2. 进入Project Settings>Tags and Layers>Rendering Layers配置渲染层级名称。
3. 在灯光组件的Rendering部分设置渲染层级。

## 光照探针

探针在场景中仅仅是一个点，在开发时会对这个位置计算全局光照，在运行时渲染一帧的时候，包含了光照计算的URP着色器会利用最近的探针进行混合得到全局光照值。

> [!NOTE] 全局光照
> 全局光照是一个模拟光线如何从表面反射到其他表面的系统，从而产生间接光，而不是仅限于直接照射到表面的光线。

在烘焙光照时，光照探针能保存环境中某个特定位置的光照数据，确保在环境中移动的动态物体的照明能够反映出烘焙物体所用的光照级别（在黑暗区域显暗，在明亮区域显亮）。由于采样是逐物体的（对于一个物体只选取一个代表性的点进行采样），所以大型物体可能引起光照异常，这种情况可以考虑使用APVs（逐像素采样）。

在Hierarchy中右键选择GameObject>Light>Light Probe Group创建光照探针，最开始会有八个探针，然后可以在Hierarchy中选中探针组，在Scene窗口中使用Edit Light Probe Group工具进行编辑。

光照探针首先应该放置在动态物体可能经过的区域，其次是光照级别发生明显变化的地方。当为物体计算光照时，引擎会找到最近的四个光照探针，然后混合它们的光照值。

放置光照探针可能比较耗时，可以通过[代码](https://docs.unity3d.com/6000.3/Documentation/Manual/LightProbes-Placing-Scripting.html)方法来加速这个操作。由于光照探针的位置在运行时是只读的，对于包含光照探针的模块化场景内容，在组合时无法重新配置光照探针，不过这个问题在Unity6中可以通过新的API解决。

## 自适应探针体积（Adaptive Probe Volumes）

因为放置探针是一项耗时的工作，而且场景的布局可能随时发生变化，然后又要重新放置探针。自适应探针体积就是为了解决这一问题的技术，它可以在数秒内自动完成探针的放置。

通过以下步骤使用APVs：

1. 在URP资产中将Light Probe System设置为Adaptive Probe Volumes
2. 在Hierarchy窗口右键选择GameObject>Light>Adaptive Probe Volume
3. 将APV模式设置为Global，保持默认的细分（Subdivision）设置
4. 点击Bake Probe Volumes，引擎会扫描当前场景并将探针放置在合适的位置
5. 在Rendering Debugger中开启Display Probes查看烘焙结果

除此以外，通过添加多个不同细分的APV，可以对探针的放置密度有更精确的控制，从而带来更高的保真度。

以下是针对[FPS Sample: The Inspection(The Inspection>Scenes>APV-Example)]示例场景的应用步骤：

1. 在Lighting窗口的Adaptive Probe Volumes页签下，将Max Probe Spacing设置为81m
2. 添加一个APV，设置为Global模式，将Override Probe Spacing设置为27m>81m
3. 添加一个APV，设置为Local模式，将Override Probe Spacing设置为1m>9m，将体积设置成比帐篷稍微大一点。
4. 烘焙探针体积。

### Lighting Scenario

APVs的另一个功能是可以在不同的间接光数据之间切换，一个Lighting Scenario资产包含了一个场景的光照烘焙数据或者烘焙集，可以将不同的光照配置烘焙到不同的Lighting Scenario，然后在运行时进行切换。

以下是使用Lighting Scenarios的步骤：

1. 在URP资产中启用Lighting > Enable Lighting Scenarios
2. 打开Lighting窗口的Adaptive Prove Volumes面板，在Lighting Scenarios部分点击+按钮添加Lighting Scenario资产。
3. 在Probe Placement部分，将Probe Positions设置为Don't Recalculate，确保Unity在重新烘焙光照时不会改变探针位置，以免使烘焙的Scenarios结果失效。
4. 在Lighting Scenarios部分，选中一个Scenario使其激活，然后点击Generate Lighting就会将烘焙结果保存到激活的Scenario中。

在运行时可以使用*ProbeReferceVolume* API来切换Lighting Scenario。

### 修复APVs带来的问题

在Rendering Debugger中开启Debug Probe Sampling，可以查看探针以及监测一个像素是如何对这些探针进行采样的。

由于探针是被放置在一个网格中的，有时可能会造成渲染上的错误，例如黑暗区域变得明亮或者反过来，编辑器提供了一些工具来让TA快速修复这些问题。

在几何内部的探针被称为**无效探针**，当从探针发射采样射线去捕获周围的光照数据时，如果射线命中了几何内部没有被照明的背面，URP就会将该探针标记为无效。

**虚拟偏移**可以通过移动探针的捕捉点，将它们移动到碰撞体之外，变成有效探针。

### 光线裂缝

光线裂缝指的是在墙壁或天花板角落里太黑或太亮的区域，通常发生在当几何接收到其不可见的光照探针的光照时。因为APVs使用的是规则网格，光照探针可能不会贴合墙壁。

采取以下方法来解决：

- 创建更厚的墙壁
- 为场景添加一个APVs Options override：添加Volume，为其设置APVs Options override，用以调整游戏对象采样光照探针的位置
- 启用Rendering Layers（渲染层级）：在Lighting窗口的APVs面板配置Rendering Layer Masks，让APV为每一个光照探针分配渲染层级遮罩
- 调整Baking Set属性
- 使用Probe Adjustment Volume组件

### 流式APVs

流式APVs用于烘焙超出CPU或GPU内存的APV数据，在运行时按需加载，当摄像机移动时，URP只加载处于摄像机视锥体之中的单元APV数据。

可以为不同的URP质量等级开启或关闭流式APVs，通过以下步骤开启流式APVs：

1. 进入Edit>Project Settings>Quality，选择一个质量等级，双击打开对应的渲染管线资产。
2. 在Lighting部分可以启用两种类型的流式：
	1. Enable Disk Streaming：从硬盘到CPU内存的流式传输
	2. Enable GPU Streaming：从CPU内存到GPU内存的流式传输，必须先开启Disk Streaming

### 天空遮蔽

当一个游戏对象对天空进行颜色采样时，如果光线无法到达这些对象，Unity会降低采样得到的颜色的亮度，这个过程叫做天空遮蔽。

在Unity中，天空遮蔽使用来自环境探针的天空颜色，会在运行时更新。这意味着当天空颜色变化时，可以动态地更新游戏对象的光照。

当开启天空遮蔽时，Unity会烘焙一个额外的静态天空遮蔽值存储到APV中的每一个探针上，天空遮蔽值代表的是探针从天空接收到的间接光量（包括从静态物体反射来的光照）。

通过以下步骤开启天空遮蔽：

1. 在Lighting窗口中的Scene面板启用Progressive GPU Lightmapper
2. 在APVs面板启用Sky Occlusion

在烘焙天空遮蔽之后，场景光照会响应环境探针的更新。在URP中，只有在使用Color或Gradient模式时，环境探针才会实时更新，这意味着必须手动处理天空颜色来匹配天空的动态视觉变化。

> [!note]
> URP支持对探针逐顶点采样，对于低端设备来说可以提升性能。在URP资产的Lighting部分的Advanced Properties中设置Evaluation Mode为Per Vertex。

### 光照探针vs自适应探针体积

| Light Probe Groups                              | Adpative Prove Volumes                        |
| ----------------------------------------------- | --------------------------------------------- |
| 放置探针耗时，几何发生改变时要重新定位                             | 放置迅速，容易更新                                     |
| 为物体计算光照时只使用一个探针插值：物体从黑暗到明亮的地方不能很好地过渡，大型物体问题更加明显 | 逐像素使用探针插值计算光照：过渡更平滑，体积效果更好                    |
| 静态物体通常使用光照贴图计算光照，只有动态物体使用探针                     | 不需要光照贴图或光照贴图UV：对场景中所有物体使用同一种照明方案，大世界照明的内存预算有限 |
| 探针可以随意放置，在运行时也能移动                               | 探针放置在一个网格结构中，不能在运行时移动                         |
| 不支持切换GI（全局光照）                                   | 使用Lighting Scenario可以切换不同的光照情景，例如从白天到晚上。      |
