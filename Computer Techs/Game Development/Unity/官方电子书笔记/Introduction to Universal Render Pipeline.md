# URP中的灯光

## 渲染器的选择

URP提供了不同的渲染技术，每一种都有其优势和缺陷，如何选择这些渲染技术取决于项目的特定需求和限制。

|          | 原理                                                                                | 优点                                                          | 缺点                                                         |
| -------- | --------------------------------------------------------------------------------- | ----------------------------------------------------------- | ---------------------------------------------------------- |
| Forward  | 场景中的物体被逐一渲染，每一个像素单独计算。这意味着对于屏幕上的每一个像素，Unity都要对场景中的每一个对象计算光照和着色，以确定它们对像素最终颜色的贡献。   | 流程相对直接，易于理解，在光源较少和材质简单的场景中表现好。                              | 由于需要为场景中每一个光源使用多个通道处理，在面对大量光源和复杂材质的场景时可能比较低效。              |
| Forward+ | 将光源分组为集群，只有处于集群当中的物体才被纳入光照计算，而不是对所有物体逐一处理每一个光源。                                   | 相比于Forward渲染，尤其在大量光源的场景下有更好的性能，能通过减少需要计算光照的物体数量来更高效地利用硬件资源。 | 在极端大量光源和复杂场景下可能仍然表现不佳，并且要实现Forward+渲染需要做更多的优化工作。           |
| Deferred | 将光照和着色计算从几何渲染过程中解耦出来。首先将几何渲染到一个缓冲区集合（包含每一个像素的位置、法线和材质属性等信息）中，然后根据缓冲区数据进行逐像素的光照计算。 | 对于渲染大量光源或复杂材质的场景非常高效，因为光照是逐像素而不是逐对象计算的。                     | 由于需要存储额外的缓冲区，内存占用会增加。对透明物体的渲染有限制，以及在处理特定类型的光照效果时有困难（如体积光）。 |
## 用于光照场景的URP着色器

| Shader      | 描述                                                                                                              |
| ----------- | --------------------------------------------------------------------------------------------------------------- |
| Lit         | 以写实质量渲染真实世界中的表面，在各种光照条件下都能获得逼真的光影和反射效果。支持烘焙、混合以及实时光照，是大多数支持光照的材质的默认选项。使用的是基于物理的着色模型，由于其着色计算的复杂性，最好避免在低端移动设备上使用。 |
| Simple Lit  | 使用非能量守恒的Blinn-Phong着色模型，更适合非基于物理着色的项目以及低端移动设备。                                                                  |
| Complex Lit | 拥有Lit的所有特性，会计算两次高光反射（基础层和位于基础层之上的模拟的一层透明薄层）。当需要使用清漆选项实现汽车的金属光泽时，选择该着色器。                                         |
| Baked Lit   | 对于不需要实时光照的对象，例如永远不会受动态物体、实时光源和动态阴影影响的远处静态物体，使用该着色器可提高性能。                                                        |
## 照亮新场景

在URP中照亮一个新场景的第一步是创建一个新的光照设置资产，通过切换光照设置资产可以在不同光照设置之间切换。

## 环境光照

最主要的环境光是在Lighting面板中的Environment页签下配置的。

可以使用场景天空盒，设置强度、渐变或颜色来设置环境光照。Skybox模式要求按需烘焙来计算天空的环境探针，只有Gradient和Color模式会实时更新。

## 阴影

### 主光源阴影分辨率

实时阴影需要渲染一张包含光源视角的物体深度数据的阴影纹理，阴影纹理的分辨率越高，阴影的视觉保真度就越高，当然也需要更多的算力和内存。影响阴影计算的因素包括：

1. 渲染在阴影纹理中的阴影投射器数量，对于主光源，该数量取决于阴影距离（URP资产Shadows模块的Max Distance）
2. 可见的阴影接收者
3. 阴影级联分段（Shadow Cascades splits）
4. 阴影过滤（软阴影）

> [!NOTE] 阴影级联
> 方向光在摄像机附近产生的实时阴影会出现像素化的问题叫做透视走样，阴影级联可以解决该问题。

最高分辨率得到的效果并不总是最理想的，例如使用软阴影时，阴影贴图会被模糊，使用高分辨率的阴影贴图会导致阴影边缘过于清晰，得不到模糊效果。

### 主光源阴影最大距离

最大距离的单位和场景单位一样，当最大距离设置太大时，阴影贴图会分散在过大的区域，导致镜头内部分的贴图分辨率远低于需求。

最大距离需要根据玩家所能看到物体的最远距离来设置，也就是说如果玩家最远只能看到离摄像机60单位的阴影，那就将该数值设置为60。

当混合光源的光照模式设置为Shadowmask时，超出阴影最大距离的物体的阴影会被烘焙，只有动态阴影才会被最大距离限制。

### 阴影级联

物体由于透视消失在远处，可以降低远距离视野的阴影分辨率，将更多的资源用于处理靠近摄像机的阴影，这就是阴影级联的核心思想。

该技术的原理是将原来的单张阴影贴图拆分为多张贴图，拆分的逻辑是根据摄像机视锥体深度划分多个层次进行分割。每张级联贴图的覆盖范围和尺寸都不同，距离越近的贴图覆盖范围和尺寸越小，主要为近处物体提供更好的细节，距离越远的贴图覆盖范围和尺寸大，阴影相对模糊，因为远处阴影不需要细节（看不清）。相邻的级联之间会进行混合，以实现平滑过渡。

对于小场景，一个级联就可达到最佳效果。如果阴影最大距离非常大，那就需要两到三个级联。

### 附加光源阴影

附加光源只在其模式设置为逐像素（Per Vertex）时，才会投射阴影。

阴影图集（Shadow Atlas）是一张组合了所有光源（能投射阴影）的阴影贴图的纹理，由于点光源需要在任何方向上投射阴影，一个点光源会投射六张阴影贴图，创建出一个立方体贴图，这就造成了点光源对性能需求是最高的。

附加光源在不同层次投射阴影的分辨率可通过Shadow Resolution tiers设置。

### 灯光模式

一般场景中静态的几何体占大多数，所以对于一个静态的光源，我们不需要实时重复地为其计算光照和阴影，只需要在开发时计算一次，在渲染时直接使用预先计算好的数据即可，这种方法叫做光照贴图映射或烘焙。

要将几何体纳入光照映射，需要在GameObject Inspector中勾选Static。

光照映射相关设置位于Lighting窗口的Scene部分，对于光照贴图的分辨率，应更尽可能小，另外可以选择Progressive GPU来加速光照贴图的生成。

Filtering会对贴图进行模糊来使噪声最小化，但是可能会导致两个物体阴影相交的地方产生缝隙，使用A-Trous滤波可以最小化这种误差。

当使用Mixed模式的灯光时，可以在Lighting窗口中将光照模式设置为以下三种：

- Baked Indirect：仅间接光会烘焙到光照贴图和光照探针，直接光和阴影是实时的。该模式非常消耗性能，不适合用于移动端。
- Subtractive：将来自Mixed模式方向光的直接光烘焙到静态几何，然后减去动态几何投射的阴影。这种模式会导致静态几何无法向动态物体投射阴影，除非使用了光照探针或自适应探针体积（ADV）。URP会对方向光的光照值进行估算，然后从全局光照烘焙中减去估值，最终的光照颜色会受到Real-time Shadow Color设置的约束。该模式是最适合低端设备的选项，但是不能将烘焙阴影和实时阴影进行结合，导致视觉瑕疵。
- Shadowmask：和Baked Indirect模式一样会结合动态和烘焙阴影，在远处也能正常渲染阴影。该模式会使用一张额外的阴影遮罩纹理，将额外信息存储在光照探针中，这能提供最高的阴影保真度，但也是最消耗性能和内存的。视觉上与Backed Indirect模式的差距在视野远处才会明显，这很适合开放世界场景，只推荐中高端设备使用。

在Mesh Renderer组件的Lightmapping中，可以调节Scale In Lightmap参数，让远处物体在光照贴图中占据更少的空间。

最后点击Lighting窗口中的Generate Lighting即可开始烘焙。烘焙时间取决于静态物体的数量，Mixed和Baked模式灯光的数量，以及光照贴图分辨率、最大光照贴图尺寸等设置，另外烘焙时间是和烘焙中使用的射线数量成正比的。

## 渲染层级

利用渲染层级可以特定的游戏物体只受特定的灯光影响，从而在场景中强调突出它们。

设置渲染层级的步骤：

1. 在URP资产的Lighting部分，点击三点图标，选择Advanced Properties，开启Use Rendering Layers。
2. 进入Project Settings>Tags and Layers>Rendering Layers配置渲染层级名称。
3. 在灯光组件的Rendering部分设置渲染层级。

## 光照探针

探针在场景中仅仅是一个点，在开发时会对这个位置计算全局光照，在运行时渲染一帧的时候，包含了光照计算的URP着色器会利用最近的探针进行混合得到全局光照值。

> [!NOTE] 全局光照
> 全局光照是一个模拟光线如何从表面反射到其他表面的系统，从而产生间接光，而不是仅限于直接照射到表面的光线。

在烘焙光照时，光照探针能保存环境中某个特定位置的光照数据，确保在环境中移动的动态物体的照明能够反映出烘焙物体所用的光照级别（在黑暗区域显暗，在明亮区域显亮）。由于采样是逐物体的（对于一个物体只选取一个代表性的点进行采样），所以大型物体可能引起光照异常，这种情况可以考虑使用APVs（逐像素采样）。

在Hierarchy中右键选择GameObject>Light>Light Probe Group创建光照探针，最开始会有八个探针，然后可以在Hierarchy中选中探针组，在Scene窗口中使用Edit Light Probe Group工具进行编辑。

光照探针首先应该放置在动态物体可能经过的区域，其次是光照级别发生明显变化的地方。当为物体计算光照时，引擎会找到最近的四个光照探针，然后混合它们的光照值。

放置光照探针可能比较耗时，可以通过[代码](https://docs.unity3d.com/6000.3/Documentation/Manual/LightProbes-Placing-Scripting.html)方法来加速这个操作。由于光照探针的位置在运行时是只读的，对于包含光照探针的模块化场景内容，在组合时无法重新配置光照探针，不过这个问题在Unity6中可以通过新的API解决。

## 自适应探针体积（Adaptive Probe Volumes）

因为放置探针是一项耗时的工作，而且场景的布局可能随时发生变化，然后又要重新放置探针。自适应探针体积就是为了解决这一问题的技术，它可以在数秒内自动完成探针的放置。

通过以下步骤使用APVs：

1. 在URP资产中将Light Probe System设置为Adaptive Probe Volumes
2. 在Hierarchy窗口右键选择GameObject>Light>Adaptive Probe Volume
3. 将APV模式设置为Global，保持默认的细分（Subdivision）设置
4. 点击Bake Probe Volumes，引擎会扫描当前场景并将探针放置在合适的位置
5. 在Rendering Debugger中开启Display Probes查看烘焙结果

除此以外，通过添加多个不同细分的APV，可以对探针的放置密度有更精确的控制，从而带来更高的保真度。

以下是针对[FPS Sample: The Inspection(The Inspection>Scenes>APV-Example)]示例场景的应用步骤：

1. 在Lighting窗口的Adaptive Probe Volumes页签下，将Max Probe Spacing设置为81m
2. 添加一个APV，设置为Global模式，将Override Probe Spacing设置为27m>81m
3. 添加一个APV，设置为Local模式，将Override Probe Spacing设置为1m>9m，将体积设置成比帐篷稍微大一点。
4. 烘焙探针体积。