
# Shader核心概念

## Shader介绍

Shader（着色器）程序，通常也被称为着色器，是一种运行在GPU上的程序。

### Shader的种类

在Unity中，Shader主要分为三类，每种类型的用处不同，用法也不同。

- 作为图形管线一部分的Shader是最常见的Shader类型，它们负责执行决定屏幕上像素颜色的计算。在Unity中，通常通过使用Shader对象来处理这种类型的Shader。
- Compute Shader在GPU上执行计算，在常规图形管线之外。
- Ray tracing Shader负责执行和光线追踪相关的计算。

### 专用术语

Shader中的专用术语可能会令人困惑，人们通常使用“Shader”一词来代表不同的东西。

- shader或shader程序：一种运行在GPU上的程序。若没有特别说明，通常指作为图形管线中的一部分的shader程序。
- Shader对象：Shader类的实例。一个Shader对象是shader程序和其他信息的包装。
- ShaderLab：用于编写Shader的Unity特定语言。
- Shader Graph：一种用于创建Shader，而无需编写代码的工具。
- shader asset：".shader"后缀的文件，它定义了一个Shader对象。
- Shader Graph asset：Unity项目中的一种文件，它定义了一个Shader对象。

## Shader类

在Unity中，当你处理图形管线中的shader时，你通常处理的是Shader类的实例，也就是Shader对象。

Shader对象是一种在Unity中处理shader程序的特定方式，它是shader程序和一些其他信息的包装，让你可以在同一文件中定义多种shader程序，并告诉Unity如何使用它们。

### 渲染管线兼容性

| 特性       | 内置渲染管线（Built-in Render Pipeline） | 通用渲染管线（Universal Render Pipeline, URP） | 高清渲染管线（High Definition Render Pipeline, HDRP） | 自定义SRP |
| -------- | -------------------------------- | -------------------------------------- | --------------------------------------------- | ------ |
| Shader对象 | 是                                | 是                                      | 是                                             | 是      |
### Shader对象基础

一个Shader对象包含shader程序，在GPU上改变设置的指令（也叫做渲染状态），以及告诉Unity如何使用它们的信息。

通过材质来使用Shader对象，改变场景的外观。

### 资产

创建Shader对象有两种方式，每一种都有其自己类型的资产：

- 通过写代码来创建一个shader资产（带有`.shader`后缀的文本文件）。
- 使用Shader Graph来创建一个Shader Graph资产。

不管使用哪种方式创建Shader对象，Unity在内部都会以同样的方式表示它们。

### Shader对象的内部

Shader对象中是一种嵌套的结构，它将信息组织进 `SubShaders`（子着色器）和`Passes`（通道）结构中，将shader程序组织进`shader variants`(shader变体)。

#### Shader对象

一个Shader对象包含以下部分：

- 关于自己的信息，比如它的名字
- 一个可选的回退Shader对象，如果Unity无法使用原本的就使用它。
- 一个或以上的子着色器。

还可以定义额外的信息，比如共享的着色器代码，或是否使用自定义编辑器。

#### SubShaders

子着色器让你可以将Shader对象拆分成若干部分，以兼容不同的硬件，渲染管线以及运行时设定。

一个子着色器包含：

- 该子着色器关于硬件，渲染管线和运行时设定的兼容信息。
- 子着色器标签，提供该子着色器信息的键值对。
- 一个或以上的通道。

还可以定义额外的信息，比如对它的所有通道通用的渲染状态。

#### Passes

一个通道包含：

- 通道标签，提供该通道信息的键值对。
- 在运行着色器程序前更新渲染状态的指令。
- 着色器程序，被组织进一个或多个shader变体。

还可以定义额外的信息，比如名字。

#### Shader variants

一个通道所包含的着色器程序会被组织进着色器变体中，它们共享通用的代码，但是当所给出的关键字状态不同时，它们的功能也会不同。

一个通道中的着色器变体的数量取决于你的着色器代码中定义了多少关键字，以及目标平台，每一个通道至少包含一个变体。

## Shader资产

Shader资产是一种在Unity项目中定义一个Shader对象的资产，它是一个`.shader`后缀的文本文件，包含了着色器代码。

### 创建一个新的shader资产

通过主菜单或者项目视图上下文菜单中`Asset>Create>Shader`，创建一个新的shader资产。

#### Inspector引用

当你在Unity项目中选择一个shader资产时，Inspector会展示关于该Shader对象定义的基本信息，同时提供了用于编译的控件，以及查看编译后的代码。

![[Pasted image 20240301175709.png]]

#### 导入设置

Inspector中的导入设置部分让你可以为shader资产设置默认的纹理，每当用该shader创建一个新的材质时，这些纹理会被自动分配。

#### 导入对象

Inspector中的导入对象部分让你可以查看和编辑关于该Shader对象的设定，以及该shader如何处理编译。

![[Pasted image 20240301180152.png]]

对于表面着色器，`Show generated code`按钮可以显示Unity从你简化过的源文件生成的代码。如果你想定制生成的代码，你只需要拷贝到你的shader源文件。

你可以使用`Compile and show code`弹出菜单：

- 根据选定的图形API，手动编译所有的shader变体。在Unity编辑器中，shader不会为所有的图形API编译所有的shader变体，直到构建时。你可以手动强制执行来检查错误。
- 根据选定的平台，查看编译后的shader代码。这在对shader进行性能优化时非常有用，你通常想知道生成了多少低层的代码，可以将生成的代码粘贴进GPU 着色器性能分析工具中。

`Preprocess Only`选择框让你可以查看该shader资产的预处理源。

## Shader编译

每次构建项目时，Unity编辑器会编译你构建需要的所有shader：对于每一个需要的图形API的每一个需要的shader变体。

当你在Unity编辑器中工作时，编辑器不会编译上面提到的一切。因为为每一种图形API都编译每一种变体，会消耗非常长的时间。

相反，Unity编辑器是这么做的：

- 当导入了一个shader资产，会执行一些非常小的处理（比如表面着色器生成）。
- 当需要显示一个shader变体时，会检查`Library/Shader Cache`文件夹。
- 如果发现之前编译的shader变体使用的是相同的源代码，则直接使用原来的。
- 如果没有找到匹配项，则编译所需的shader变体并将结果保存到缓存中。
	注：如果开启了`Asynchronous shader compilation`，则会在后台执行这个操作，同时显示一个占位shader。

shader编译是用一个叫做`UntiyShdaerCompiler`的进程所执行的，可以启动多个`UnityShaderCompiler`进程（通常一个CPU核心对应一个），所以shader编译能够在玩家构建时并行完成。当编辑器不在编译shader时，编译器进程不会占用计算机资源。

如果经常修改大量的shader，shader缓存文件夹可能会变得非常大，删除该文件夹是安全的，只是Unity需要重新编译这些shader变体。

在玩家构建时，所有"尚未编译”的shader变体都会被编译，所以即使编辑器还没有使用过它们，它们也会在游戏数据中存在。

### 不同的shader编译器

不同平台使用不同的shader编译器来编译shader程序，如下：

- 使用DirectX的平台：Microsoft's FXC HLSL编译器。
- 使用OpenGL（Core & ES）的平台：Microsoft’s FXC HLSL编译器，然后使用HLSLcc将字节码转译成GLSL。
- 使用Metal的平台：Microsoft’s FXC HLSL编译器，然后使用HLSLcc将字节码转译成GLSL。
- 使用Vulkan的平台：Microsoft’s FXC HLSL编译器，然后使用HLSLcc将字节码转译成SPIR-V。
- 其他平台如控制台：各自的编译器。
- 表面着色器使用HLSL和MojoShader进行代码生成分析步骤。

可以使用`pragma directives`配置不同的shader编译器。

### Caching Shader Preprocessor

Shader编译包含多个步骤，第一步是预处理。预处理时，会有一个叫做`preprocessor`(预处理器)的程序为编译器准备shader的源代码。

在之前的Unity版本中，编辑器使用当前平台的shader编译器所提供的预处理器。而现在，Unity使用它自己的预处理器，也叫做`Caching Shader Preprocessor`(缓存着色器预处理器)。

Caching Shader Preprocessor为更快的shader导入和编译做了优化，它通过缓存中间预处理数据来工作，所以编辑器只需要在预处理数据发生改变时解析包含文件，使编译同一shader的多个变体时更加高效。

### AssetBundle和shader

如果使用AssetBundle在两个或以上的对象中引用同一个shader，Unity可能会编译重复的shader，例如：

- 在AssetBundle中的某个材质，以及在场景中的某个材质，引用了相同的shader。
- 多个AssetBundle中，包含了引用不在AssetBundle中的同一shader的材质。

这会增加shader使用的内存和存储空间，以及打断`draw call batching`。

可以使用以下方法避免这种情况：

- 首先加载包含所有shader的AssetBundle，然后再加载和实例化引用了shader的AssetBundle资产。
- 组织AssetBundle，减少重复和冗余。

可以在一个AssetBundle中添加材质和shader变体的集合，来指定要包含哪些shader变体。

如果你创建了一个单独的AssetBundle，由于你无法部分地卸载AssetBundle，所以即使某些shader不再被需要，但是它们可能还保留在内存中。你可以通过为一起使用每一组shader创建一个单独的AssetBundle，例如一个森林的AssetBundle，一个沙漠的AssetBundle。

可以使用Asset Bundle Browser来检查AssetBundle中的资产依赖关系，找出重复的资产。

## 分支、变体和关键字

有时，你想让同一个shader在不同情况下做不同的事情，可以使用条件来定义不同硬件的不同行为。

### 着色器中的条件

有时你可能希望为不同的材质配置不同的设定，为不同的硬件定义功能，或者在运行时动态改变shader的行为。你可能还会想避免在不必要时执行高计算成本的代码，比如纹理读取，顶点输入，插值或循环。

你可以使用条件来定GPU只在特定情况下的行为。

#### 不同类型的条件

在shader中使用条件，可以使用以下方法：

- 静态分支：shader编译器会在编译时计算条件代码。
- 动态分支：GPU会在运行时计算条件代码。
- Shader变体：Unity会使用静态分支将shader源代码编译到多个shader程序中，然后在运行时使用满足条件的shader程序。

#### 何时使用哪种类型的条件

没有“一刀切”的方法，应该根据特定的项目和shader，综合考虑每一种方法的优劣势来决定。

使用哪种方法取决于何时需要shader切换到不同的代码分支：

- 仅在编辑时
- 在运行时

##### 在编辑时切换代码分支

如果你的shader不需要在运行时切换不同的代码分支，可以使用Unity仅在编辑时计算的条件。

例如你可以在材质的Inspector窗口中设置一个属性，来使shader做以下事情：

- 为材质的某些实例添加镜面反射
- 为特定对象添加不同的外观，比如出现在水下场景的对象。

如果使用这种方法，shader代码的编写和维护会更简单，而且极少可能会影响构建时间，文件大小和性能。

为此，使用以下的其中一种方法：

- Shader变体：使用`shader_feature`来声明关键字，在`if`语句中计算它们。
- 静态分支：使用预处理器常量和宏。

如果使用`shader_feature`关键字定义，Unity会在你的构建中保持材质使用的shader变体，然后移除其他的shader变体，这样可以缩短构建时间，降低文件大小。

避免使用C#脚本在运行时开启或禁用`shader_feature`，因为如果一个材质使用的shader变体丢失了，Unity会选择另一个可用的变体替代。如果确实需要那样做，使用以下方法确保构建包含了所有需要的shader变体。

- 在预加载着色器（preloaded shaders）列表中，添加你需要的shader变体。
- 在构建中为你想使用的每种`shader_feature`关键字组合，添加一个材质。

##### 在运行时切换代码分支

如果你需要在运行时使用C#脚本使shader切换到不同的代码分支，你可以使用Unity在编辑和运行时都会评估的条件语句。

例如，你可以使用C#脚本来让shader做以下事情：

- 在特定时间动态改变材质，实现积雪效果。
- 当用户修改画质设定时改变材质，例如让用户动态控制是否出现雾。

为此，可以使用以下方式之一：

- Shader变体：使用`multi_compile`来声明关键字，然后再`if`语句中评估它们。
- 动态分支。

如果使用`multi_compile`关键字定义，Unity会为每一种可能的shader代码分支组合都构建一个shader变体，包括那些没有被材质所使用的变体。这意味着你可以在运行时启用或禁用关键字，但是可能会大大增加构建时间，文件大小，加载时间和内存使用。

动态分支不会创建shader变体，但那也许意味着你的shader在GPU上会运行得更慢，特别是在以下情况中：

- 你的shader运行在一个性能比较差的GPU上。
- 你的条件代码具有“不对称”分支，体现在某一个分支的代码比其他分支更长或更复杂。

你可以查看shader变体的数量，来确认是否可以使用动态分支，而不太过影响GPU的性能。

### 着色器中的分支

> 分支是在shader代码中引入条件行为的一种方式。

#### 静态分支

当一个shader程序包含了在编译时被评估的条件时，它使用静态分支。编译器会剔除没有使用的分支代码，所以它不会出现在编译后的shader程序中。

在内部，当Unity创建shader变体时，使用的是静态分支。静态分支本身不会有和shader变体一样的性能劣势。

##### 静态分支的优劣势

静态分支的主要优势是它不会对运行时的性能产生负面影响，主要劣势是仅仅只能在编译时使用它。

使用静态分支，意味着编译器会剔除shader程序中所有不需要的代码。静态分支在运行时不会有性能消耗，事实上，更小的程序可能带来更快的加载时间和更低的运行时内存使用。

为了使用静态分支，条件在编译时必须是常量，这意味着你不能在运行时使用它来执行不同条件对应的代码。

##### 如何使用静态分支

可以在你的shader（手写代码）中通过以下方式使用静态分支：

- 使用`#if`，`#elif`，`#else`，和`#endif`，或者`#ifdef`和`#ifndef`预处理器指令来创建静态分支。
- 使用评估编译时常量值的`if`语句。虽然`if`语句也可以用于动态分支，但编译器能检测到编译时常量值，从而创建一个静态分支。
- Unity为一些编译时常量提供了内置的宏，可以用于静态分支。

注：静态分支只能用于手写代码的shader，所以不能在Shader Graph中使用静态分支。

#### 动态分支

当shader程序包含了在运行时评估的条件，它使用动态分支。

动态分支有两种类型：基于`uniform`变量的动态分支，和基于任何其他运行时值的动态分支。

基于uniform的分支通常更高效，因为整个draw call中统一值是不变的。

你可以为动态分支使用着色器关键字，这让你可以使用C#脚本以及材质Inspector为你的shader配置运行时分支。这样会形成基于uniform的分支，当你这样做时，Unity会将着色器关键字编译为uniform。

##### 动态分支的优劣势

动态分支的主要优势在于它允许你在运行时使用条件语句，而不会增加项目中shader变体的数量。主要劣势是它会影响GPU性能。

影响GPU性能的因素是多样的，可以是硬件，也可以是shader代码。原因是：

- 基于非uniform变量的分支意味着GPU必须同时执行不同的操作（从而打破并行性），或者“展平分支”并通过执行两个分支的操作然后放弃一个结果来保持并行性。基于uniform变量的分支意味着GPU必须展平分支。这两种方法都会导致GPU性能降低。
- 对于任何类型的动态分支，GPU必须为最坏的情况分配寄存器空间。如果一个分支比其他分支更消耗资源，就意味着GPU会浪费寄存器空间。这可能会导致并行调用shader程序的次数减少，从而降低性能。

一般而言，如果你的代码分支是基于uniform值的，而且所有分支都有大致相似的工作量，那么对GPU性能的影响可能会小。然而，你应该始终对应用程序进行分析，考虑每种情况的优缺点。

注：动态分支也有可能导致较大的shader程序，因为所有条件的代码都会被编译进同一个shader程序。但是，这些大文件对加载时间和内存使用的影响通常不如shader变体的影响显著。

##### 如何使用动态分支

可以通过以下方式在你的shader中使用动态分支：

- 手写代码的shader中：
	- 可选的：设置用于动态分支的着色器关键字。你可以在不适用着色器关键字的情况下使用动态分支，但这提供了简单的设置和各材质配置。
	- 使用一个`if`语句评估着色器关键字或任何其他的运行时状态。你可以使用特性来强制GPU执行两个分支，或者只执行一个分支。
- 在Shader Graph中，使用一个分支结点，这始终会执行两个分支。