# 渲染管线

Unity每渲染一帧时，都会重复执行这几个步骤。

1. 剔除。决定哪些物体能够被显示，通常会移除摄像机视野外的物体。
2. 渲染。将物体以正确的光照渲染成屏幕上的像素。
3. 后处理。对像素进一步处理，产生最终的屏幕图像输出。

Unity提供3种不同的预制渲染管线，根据兼容性和性能来考虑选择，也可以创建自己的渲染管线。

## 可编程渲染管线基础

[可编程渲染管线（SRP）](https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@17.0/manual/index.html)是一个精简的API层，让我们能够使用C#来配置渲染指令，这些指令会被传送到Unity的底层图形架构，最后由图形API来执行。

URP和HDRP都是基于SRP的，你也可以基于SRP创建自己的管线。

基于SRP的渲染管线都有两个关键的定制要素：**渲染管线实例**和**渲染管线资产**。

- 渲染管线实例：定义了渲染管线功能的类（继承于RenderPipeline，重写了Render方法）的实例。
- 渲染管线资产：存储了关于如何使用渲染管线实例以及如何配置的数据，继承于RenderPiplelineAsset，重写了CreatePipeline方法。

[RenderPipelineContext](https://docs.unity3d.com/Packages/com.unity.render-pipelines.core@17.0/manual/srp-using-scriptable-render-context.html)是一个类，提供使用C#代码访问Unity底层图形API的能力。

## 如何选择渲染管线

[Unity - Manual: Choosing a render pipeline](https://docs.unity3d.com/6000.0/Documentation/Manual/choose-a-render-pipeline-landing.html)

## URP

### 基础概念

URP使用以下组件渲染场景：

- URP渲染器：包括通用渲染器和2D渲染器
- URP着色器的着色模型
- 摄像机
- URP资产

下图展示了URP通用渲染器的帧渲染循环。

![[Pasted image 20241104193916.png]]

URP渲染器会为场景上的每一个摄像机执行Camera Loop。

- 设置剔除参数：配置剔除系统如何剔除灯光和阴影的相关参数。
- 剔除：使用剔除参数计算出可见的渲染器、阴影转换器和摄像机可见的灯光。剔除参数和摄像机层距离会影响剔除和渲染的性能。
- 构建渲染数据：获取基于剔除结果、品质设置、摄像机和当前平台的信息，构建出渲染数据。渲染数据用来告诉渲染器，当前摄像机和运行平台需要的渲染操作和渲染质量。
- 设置渲染器：构建一系列渲染器通道，加入渲染队列。
- 执行渲染器：根据渲染数据来按队列顺序依次执行，渲染器会在帧缓冲区输出摄像机图像。

### 渲染路径

渲染路径是将摄像机所看到的游戏对象绘制出来并提供照明的一系列操作。

#### Forward

前向渲染是Unity中默认的渲染路径，其按以下方式工作：

- 逐一点亮每一个游戏对象。
- 对于照明的频率和质量是有限制的，并且在不同的渲染管线中会有所区别。

内置渲染管线中还有顶点照明渲染路径，是前向渲染的子集。

#### Deferred

- Unity首先会创建一个几何缓冲区(G-Buffer)，G-Buffer是一个存储摄像机所使用的关于几何和材质数据的纹理集合。
- Unity使用G-Buffer中的数据一次性将所有游戏对象点亮。
- 由于在照明上的限制更少，游戏对象和阴影的渲染会有更多细节。

延迟渲染路径不能渲染透明物体，因此Unity会在该渲染路径执行结束时使用一个前向渲染的通道来渲染透明物体。

> 对玩家系统的要求

Deferred渲染路径对玩家系统的要求和限制如下：

- 支持最小的Shader Model版本是4.5
- 不支持Open GL和Open GL ES的API

> 每个摄像机可见的光源限制

所有的渲染路径都有可见光源数量的限制。

对于Forward和Deferred渲染路径：

- 桌面和主机平台：1个主光源，256个额外光源
- 移动平台：一个主光源，32个额外光源。OpenGL ES 3.0和更早的版本：一个主光源，16个额外光源

对于Forward+渲染路径，以相同方式处理所有的光源，因此比Forward和Deferred要少一个光源。

#### 设置渲染路径

在渲染器资产文件中，Lighting > Rendering Path 可以选择渲染路径。

### 配置URP以获得更好的性能

根据项目和目标平台，以下方面可能对性能影响最大：

- 选择的渲染路径
- URP使用的内存容量
- CPU处理时间
- GPU处理时间

#### 减少URP使用的内存

在URP资产中做以下事情：

- 禁用深度纹理
- 禁用不透明纹理
- 禁用渲染层(Deferred)，这样URP不会创建额外的渲染目标
- 禁用HDR，如果要使用，则将精度设置为32bit
- 降低阴影分辨率，Main Light > Shadow Resolution，Additional Lights > Shadow Atlas Resolution
- 禁用Light Cookies，或降低Cookies Resolution 和 Cookies Atlas Format
- 在低端设备上，设置Store Actions为Auto或Discard

在URP渲染器资产中，可以设置Intermediate Texture为Auto，以减少使用的GPU带宽。

[Unity - Manual: Configure for better performance in URP](https://docs.unity3d.com/6000.0/Documentation/Manual/urp/configure-for-better-performance.html)

#### 减少CPU处理时间

在URP资产中做以下事情：

- 设置Volume Update Mode为Via Scripting，这样URP就不会每帧更新volume，但是需要你通过API（例如UpdateVolumeStack）手动更新。
- 在低端设备上，如果使用反射探针，则禁用Probe Blending和Box Projection。
- 在Shadows部分，禁用Max Distance，使URP在阴影通道处理更少的物体。
- 在Shadows部分，禁用Cascade Count，减少渲染通道数量。
- 在Additional Lights部分，禁用Cast Shadows。

因为场景中每一个摄像机都需要给URP的剔除和渲染工作提供资源，所以尽量减少摄像机的使用数量。

#### 减少GPU处理时间

在URP资产中做以下事情：

- 降低或禁用Anti-aliasing（MSAA）
- 禁用Terrain Holes
- 启用SRP Batcher，这样URP可以降低Draw Call之间的GPU设置时间，并让材质数据在显存中持久化。
- 在低端移动平台，禁用LOD Cross Fade，这样URP就不会使用alpha测试来让LOD网格淡入淡出。
- 设置Additional Lights为Disabled，或者Per Vertex（Forward路径）。
- 禁用Soft Shadows，或降低其品质。

在Universal Renderer资产中：

- 若使用Vulkan，Metal 或 DX12，启用Native RenderPass
- 若使用Forward或Forward+路径，在主机和PC平台上设置Depth Priming Mode为Auto或Forced，在移动平台上将其禁用。
- 设置Depth Texture Mode为After Transparents，可以避免URP在透明和不透明通道之间切换渲染目标。

还可以：

- 避免使用Complex Lit shader，它有非常复杂的光照计算。如果要使用，则禁用Clear Coat。
- 在低端移动平台，对静态物体使用Baked Lit shader，对动态物体使用Simple Lit shader。
- [使用SSAO时的设置](https://docs.unity3d.com/6000.0/Documentation/Manual/urp/post-processing-ssao.html)。

### 自定义渲染和后处理

可编程渲染通道是一种改变Unity如何渲染场景的方式，通过插入一个渲染通道到渲染管线中可以实现自定义的视觉效果。

可编程渲染通道能做什么：

- 改变场景中材质的属性
- 改变Unity渲染游戏对象的顺序
- 让Unity读取摄像机缓存以在Shader中使用

例如，可以使用可编程渲染通道实现在显示游戏菜单时模糊摄像机的画面。

Unity会在URP渲染循环期间将渲染通道注入到的特定位置，这些位置称为注入点。通过设置不同的注入点，可以控制渲染通道如何影响场景的渲染结果。

#### 通过可编程渲染通道添加预构建效果

Unity在DrawOpaqueObjects和DrawTransparentObjects通道中绘制物体，而你可能需要在帧渲染当中的不同位置绘制物体，或者以其他方式解释和写入渲染数据（比如深度和模板）。

使用Render Objects Renderer Feature就可以在特定的层级、特定的事件、使用特定的覆盖来绘制物体，以完成这种自定义的需求。

[Unity - Manual: Add a Renderer Feature to a URP Renderer](https://docs.unity3d.com/6000.0/Documentation/Manual/urp/urp-renderer-feature.html)

#### 自定义渲染通道流程

自定义渲染通道是一种改变渲染管线如何渲染场景和物体的方法，它包含了你自己写的插入到某一个注入点的渲染代码。

添加一个自定义的渲染通道：

1. 使用Scriptable Render Pass的API编写自定义渲染通道的代码。
2. 通过创建一个Scriptable Renderer Feature，或使用RenderPipelineManager的API，将自定义渲染通道添加到URP的帧渲染循环中。

> 为自定义渲染通道编写代码

创建一个继承于ScriptableRenderPass的类，在其中使用render graph的API告诉Unity要使用什么纹理和渲染目标以及在上面做什么操作。

> 创建Scriptable Render Feature

为了将渲染通道添加到渲染循环，创建一个继承于ScriptableRendererFeature的类，这个类用于：

1. 创建自定义渲染通道的实例
2. 将自定义渲染通道插入到渲染管线中

另外也可以通过订阅RenderPipelineManager中的事件来添加渲染通道。

#### URP中的Blit

使用可编程渲染管线核心中的Blitter API，可以在一个自定义的渲染通道中将一张纹理的数据传送到另一张纹理。

> Blit的解释：A shorthand term for “bit block transfer”. A blit operation is the process of transferring blocks of data from one place in memory to another.

使用Blitter API的Shader必须手写，Shader Graph并不兼容Biltter API。

注：不要使用CommandBuffer.Blit或Graphics.Blit或在内部使用了它们的API，例如RenderingUtils.Blit，因为这些API可能会打断XR的渲染，并且不兼容原生的渲染通道。

#### Render graph system

Render graph system是一个用来创建可编程渲染通道（Scriptable Render Pass）的API集合。

当使用render graph API来创建可编程渲染通道时，就是告诉URP做以下事情：

1. 要使用的纹理或渲染纹理，该阶段是一个记录阶段
2. 要执行的图形命令，并使用来自上一阶段的纹理或渲染纹理，该阶段是执行阶段。

接下来就可以将可编程渲染通道添加到URP渲染器中了，可编程渲染通道会变成URP内部渲染图的一部分，即URP每帧都会按步骤执行的一个渲染通道序列。URP会自动优化这些渲染通道和渲染图，以最小化渲染通道的数量，以及所使用的内存和带宽。

> URP如何优化渲染

- 将多个渲染通道合并到一个渲染通道中
- 避免分配帧当中不使用的资源
- 如果最终帧不使用某个渲染通道的输出，则避免执行它们
- 避免重复资源，例如放置两张具有相同属性的纹理
- 自动同步计算和图形GPU命令队列

对于使用基于块的延迟渲染，URP也可以将多个渲染通道合并为一个单独的原生渲染通道。原生渲染通道会保持纹理数据在内存块中，而不是将纹理从GPU拷贝到CPU，因此URP能使用更少的内存带宽和渲染时间。

#### 使用渲染图系统编写渲染通道

> 声明一个渲染通道

即声明一个继承于ScriptableRenderPass的类。

> 声明渲染通道使用的资源

在渲染通道内部声明一个包含需要使用的资源的类，以便渲染图系统在渲染代码执行期间访问这个数据结构。资源可以是常规的C#变量和渲染图资源引用，确保仅声明了渲染通道需要使用的变量，增加不必要的变量会降低性能。

RecordRenderGraph方法用于填充数据，然后渲染图会将数据作为一个参数传递到渲染方法中。

> 声明为渲染通道生成渲染命令的渲染方法

如下，RecordRenderGraph方法会命令渲染图使用一个使用了`SetRenderFunc`的方法。

```C#
static void ExecutePass(PassData data, RasterGraphContext context)
{
    // Records a rendering command to copy, or blit, the contents of the source texture
    // to the color render target of the render pass.
    // The RecordRenderGraph method sets the destination texture as the render target
    // with the UseTextureFragment method.
    Blitter.BlitTexture(context.cmd, data.copySourceTexture,
        new Vector4(1, 1, 0, 0), 0, false);
}
```

> 实现RecordRenderGraph方法

利用RecordRenderGraph方法在渲染图系统中添加并配置一个或多个渲染通道。

Unity会在渲染图配置步骤中调用这个方法，并使你能够为渲染图的执行注册相关的通道和资源，从而实现自定义渲染。

在RecordRenderGraph方法中可以声明渲染通道的输入和输出，但不要添加命令到命令缓冲区。

 > 渲染图builder变量和帧资源
 
 builder变量是IRasterRenderGraphBuilder结构的一个实例，也是配置渲染通道相关信息的入口。

UniversalResourceData类包含了URP使用的所有纹理资源，包括摄像机的激活颜色和深度纹理。

UniversalCameraData类包含了和当前激活的摄像机相关的数据。

下面的样例创建了一个临时目标纹理，UniversalRenderer.CreateRenderGraphTexture是一个辅助方法，其调用了RenderGraph.CreateTexture方法。

```C#
TextureHandle destination = UniversalRenderer.CreateRenderGraphTexture(renderGraph, desc, "CopyTexture", false);
```

builder.UseTexture方法声明了这个渲染通道使用源纹理作为一个只读输入。

```CS
builder.UseTexture(passData.copySourceTexture);
```

在这个例子中，builder.SetRenderAttachment方法声明了这个渲染通道使用临时的目标纹理作为它的颜色渲染目标，和cmd.SetRenderTarget（非渲染图API）类似。

SetRenderFunc方法设置ExecutePass方法作为渲染图在执行渲染通道时调用的渲染方法，样例中使用了一个lambda表达式来避免内存分配。

```CS
builder.SetRenderFunc((PassData data, RasterGraphContext context) => ExecutePass(data, context));
```

> RecordRenderGraph方法的完整代码

```CS
// This method adds and configures one or more render passes in the render graph.
// This process includes declaring their inputs and outputs,
// but does not include adding commands to command buffers.
public override void RecordRenderGraph(RenderGraph renderGraph, ContextContainer frameData)
{
    string passName = "Copy To Debug Texture";

    // Add a raster render pass to the render graph. The PassData type parameter determines
    // the type of the passData output variable.
    using (var builder = renderGraph.AddRasterRenderPass<PassData>(passName,
        out var passData))
    {
        // UniversalResourceData contains all the texture references used by URP,
        // including the active color and depth textures of the camera.
        UniversalResourceData resourceData = frameData.Get<UniversalResourceData>();

        // Populate passData with the data needed by the rendering function
        // of the render pass.
        // Use the camera's active color texture
        // as the source texture for the copy operation.
        passData.copySourceTexture = resourceData.activeColorTexture;

        // Create a destination texture for the copy operation based on the settings,
        // such as dimensions, of the textures that the camera uses.
        // Set msaaSamples to 1 to get a non-multisampled destination texture.
        // Set depthBufferBits to 0 to ensure that the CreateRenderGraphTexture method
        // creates a color texture and not a depth texture.
        UniversalCameraData cameraData = frameData.Get<UniversalCameraData>();
        RenderTextureDescriptor desc = cameraData.cameraTargetDescriptor;
        desc.msaaSamples = 1;
        desc.depthBufferBits = 0;

        // For demonstrative purposes, this sample creates a temporary destination texture.
        // UniversalRenderer.CreateRenderGraphTexture is a helper method
        // that calls the RenderGraph.CreateTexture method.
        // Using a RenderTextureDescriptor instance instead of a TextureDesc instance
        // simplifies your code.
        TextureHandle destination =
            UniversalRenderer.CreateRenderGraphTexture(renderGraph, desc,
                "CopyTexture", false);

        // Declare that this render pass uses the source texture as a read-only input.
        builder.UseTexture(passData.copySourceTexture);

        // Declare that this render pass uses the temporary destination texture
        // as its color render target.
        // This is similar to cmd.SetRenderTarget prior to the RenderGraph API.
        builder.SetRenderAttachment(destination, 0);

        // RenderGraph automatically determines that it can remove this render pass
        // because its results, which are stored in the temporary destination texture,
        // are not used by other passes.
        // For demonstrative purposes, this sample turns off this behavior to make sure
        // that render graph executes the render pass. 
        builder.AllowPassCulling(false);

        // Set the ExecutePass method as the rendering function that render graph calls
        // for the render pass. 
        // This sample uses a lambda expression to avoid memory allocations.
        builder.SetRenderFunc((PassData data, RasterGraphContext context)
            => ExecutePass(data, context));
    }
}
```