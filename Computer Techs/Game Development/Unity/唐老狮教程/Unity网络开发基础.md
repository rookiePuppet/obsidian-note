# 理论基础

## 网络基本概念

#### 网络的作用

在有网络之前，每个人的设备都是彼此孤立的，网络的出现让设备之间可以相互通信。

网络是由若干设备和连接这些设备的链路构成的，各种设备间接或直接通过介质相连。

设备之间进行信息传递时，将数据编码成二进制数值，并且以电脉冲的形式进行传输。

线缆中的电压在高和低两种状态之间进行变化，高电压表示1，低电压表示0。

### 网络的分类

#### 局域网（LAN）

指在某一个小区域内由多台设备互联成的计算机组。

特点是分布地区范围有限，一般在方圆几千米之内。

###### 以太网

以太网是一种计算机局域网技术，目前应用最普遍。

局域网中设备的连接规范，数据的传输规范等等规则都是基于以太网的技术标准来完成的。

简单来说，以太网就是网络连接的一种规则（协议）。

###### 以太网网络拓扑结构

用传输媒体把计算机等各种设备互相连接起来的物理布局，指设备互连过程中构成的几何形状。

- 总线型
- 环形
- 星形
- 网状
- 树形

#### 城域网（MAN）

在一个城市范围内建立的网络，通常覆盖一个城市，从几十公里到一百公里不等，可能会有多种介质，用户也比局域网更多。

#### 广域网（WAN）

连接不同地区局域网或城域网设备通信的远程网，通常跨接很大的物理范围，从几十公里到几千公里，可以连接多个地区、城市和国家。

*！广域网不等同于互联网。*

#### 互联网（因特网）

一般泛指彼此能够通信的设备组成的网络，但是目前我们提到的互联网，往往指的是因特网，可以把互联网作为名词理解，也可以把互联网作为因特网的代称。 

互联网的本质就是认为定义的一系列协议，称为互联网协议。定义计算机如何接入互联网，以及接入互联网的计算机的通信标准，并为传输的二进制数据定义一些传输规则。

#### 万维网（WWW）

万维网是由一系列通过超文本链接连接在一起的文档组成，基于互联网的一种信息服务系统。

是无数个网络站点和网页的集合，是构成因特网的主要部分。

如果把因特网看作网络的基础，那么万维网就是因特网的应用，是利用因特网规则的一种信息传递和呈现的手段，可以认为万维网是网站和页面的统称。

## IP、端口、Mac地址

### IP

IP地址也称为互联网协议地址，是IP协议提供的一种统一的地址格式。

#### IPv4

互联网协议第四版，由四个数组成，每个数取值范围是0~255，用点分隔。

#### IPv6

互联网协议第六版，由八个数组成，每个数取值范围是0~65535，用冒号分隔。

### 端口

通过IP地址可以找到网络上的一台设备，但是要和设备上的应用程序进行通信，那就必须指定端口号来确定是和哪一个应用程序通信。

端口号的取值范围是0~65535，在进行网络程序开发时，需要为程序指定一个端口号，且避免和其他程序的端口相同，一般选择1024以上的端口号。

### Mac地址

Mac地址是用来确定网络设备位置的地址，用于在网络中唯一标识一个网卡。

由12个十六进制数组成，长度为48位。

前3个字节代表网络硬件制造商编号，后三个字节代表网络产品的系列号。

Mac地址是物理层面上通信的基础，而IP地址是逻辑层面上通信的基础。

## 客户端与服务端

客户端即用户使用的设备，而客户端程序就是用户这些设备上使用的程序。

服务端是为用户提供服务的设备，通常是一台性能较好的计算机，而服务端程序就是为客户端提供服务的应用程序。

## 数据通信模型

在早期的计算机网络中，一般将数据通信模型分为：分散式、集中式、分布式，不同方式决定了数据在网络环境中的管理方式。

### 分散式

用户只负责管理自己的计算机系统，计算机之间相互独立，没有资源交换和共享。

造成数据冗余和数据不一致问题，维护成本高，因此被淘汰。

### 集中式

所有数据都存储在一台计算机上，用户通过连接和该计算机通信，访问数据。

方便数据共享，消除了数据冗余和不一致问题，但可靠性低，因为主机一旦出现故障，所有系统就都瘫痪了。

### 分布式

结合了分散式和集中式的特性，是分散式的水平交互和集中式的垂直控制相结合的一种模式。

### C/S 模型

即客户端/服务器模式，目前大多数网络通信采用的模型。

### B/S 模型

基于Web的通信模型，使用HTTP协议通信。

是特殊的C/S 模型，客户端一般是浏览器。

### P2P 模型

也叫对等互联，一个应用程序同时作为客户端和服务端。

通信方便，成本低，可靠性不如C/S 模型。

## 网络协议

网络协议指的是在计算机网络中，相互通信的计算机设备之间交换信息必须遵守的规则。

### OSI 模型

OSI 即开放式系统互联通信参考模型，是一种概念模型。

该模型定义了网络互联的标准，让遵循标准的各个计算机设备之间能够进行通信。

模型采用了分而治之的设计方法，将网络划分为多个层次和模块，并将它们有机组合在一起。

#### 物理层

将二进制数据利用电脉冲在物理媒介上实现比特流传输，主要功能是定义传输模式、传输速率、比特同步、比特编码等。

#### 数据链路层

确定二进制数据的分组方式，明确信息发送给哪台计算机的网卡。

将要发送的信息封装成数据包（帧），每个帧包含标头和数据两部分，标头包括发送和接收方的Mac地址、数据类型等。

包括的协议：PDDI、Ethernet、PDN、PPP。

#### 网络层

主要作用是IP选址、路由选择，在网络中选择合适的路径进行通信。

在上一层的基础上添加标头信息，包括IP地址、版本、长度等。

包括的协议：IP、ICMP、ARP、RARP、AKP。

#### 传输层

主要作用是建立端口之间的连接，负责主机中两个进程之间的通信，为端到端提供可靠的传输服务。

在上一层的基础上添加标头信息，包括发送和接收方的端口信息、协议信息等。

包括的协议：TCP、UDP。

#### 应用层

为应用程序提供服务，可以根据要传递的信息来选择相应的协议来处理数据，进行传输。

在原始数据的基础上添加标头信息，包括协议信息等。

包括的协议：FTP、NFS、WAIS。

#### 表示层

将数据转换成与不同系统兼容以及适合传输的格式，以便在不同操作系统和设备上通用。

主要功能有数据格式转换、代码转换、数据加密。

包括的协议：Telnet、SNMP、Rlogin、Gopher。

#### 会话层

负责建立、管理和维护会话，不参与具体的数据传输，主要提供建立和维护通信的机制。

包括的协议：SMTP、DNS。

### TCP/IP 协议

TCP/IP 即传输控制/网络协议，是一组能够在多个不同网络之间实现信息传输的协议。

不仅仅包含TCP和IP协议，还包含FTP、SMTP、UDP等等协议。

TCP/IP 协议是对OSI 模型的一个具体实现，是为解决特定的问题而生。

#### 应用层

对应OSI 模型的应用层、表示层和会话层，为应用程序提供服务。

负责选择传输协议，格式化数据、加密解密和建立、维护会话。

包括的协议：HTTP、HTTPS、FTP、SMTP、DNS。

#### 传输层

和OSI 模型的传输层一致。

包括的协议：TCP、UDP。

#### 网络层

和OSI 模型的网络层一致。

包括的协议：IP、ARP。

#### 网络接口层

对应OSI 模型的物理层和数据链路层，即传输数据的物理媒介，提供一条准确的传输线路。

包括的协议：HDLC、PPP、SLIP。

### TCP和UDP

#### 区别

|      | TCP              | UDP             |
| ---- | ---------------- | --------------- |
| 连接方面 | 面向连接             | 无连接             |
| 安全方面 | 无差错、不丢失、不重复、按序到达 | 只会尽力交付，不保证可靠性   |
| 传输效率 | 相对较低             | 相对较高            |
| 连接对象 | 一对一              | 一对一、一对多、多对一、多对多 |

#### TCP

三次握手$\rightarrow$建立连接：

1. 客户端向服务端请求建立连接
2. 服务端回应客户端接受请求
3. 客户端向服务端确认建立连接

四次挥手$\rightarrow$断开连接：

1. 客户端通知服务端数据已经发送完成
2. 服务端回应客户端要求等待剩余消息发送完成
3. 服务端通知客户都安数据已经全部发送完成，可以断开连接
4. 客户端回应服务端断开连接

有了三次握手和四次挥手，TCP才能做到无差错、不丢失、不重复、且数据按序到达的可靠服务。

适合对信息准确性要求高，效率要求较低的场景，如游戏开发、文件传输、远程登录等。

#### UDP

无需建立连接，提供面向事务的简单不可靠信息传送服务。

特点是：

1. 无连接：发送方与接收方不需要建立连接
2. 可靠性低：消息可能在传输过程中丢失，丢失后不会重发
3. 传输效率高：因为无需建立连接，所以传输效率高
4. n对n：因为无连接，可以多对多

适合对实时性要求高的场景，如直播、即时通讯、游戏开发等。

# 网络通信

## 网络游戏通信方案概述

### 强联网与弱联网

弱联网游戏不会频繁地进行数据通信，客户端与服务端每次连接只处理一次请求，服务端处理完成返回数据之后就断开连接。

一般的三消类休闲游戏、卡牌游戏等都是弱联网游戏，游戏的核心玩法都在客户端完成，由服务端验证游戏结果，不需要随时通信，比如开心消消乐、我叫MT。

---

强联网游戏需要和服务端频繁通信，会一直保持连接状态，不停地和服务端交换数据。

一般的MMO、MOBA、ACT等都是强联网游戏，游戏的部分核心逻辑由服务端处理，客户端和服务端之间需要不停地同步消息，比如王者荣耀、和平精英等。

### 长连接和短连接

短连接游戏在需要通信时建立连接，通信完毕时断开连接。

通信方式采用HTTP、HTTPS协议（本质上是TCP）。

---

长连接游戏一直和服务端建立连接，实时传输数据，除非一端主动断开或出现意外情况。

通信方式采用TCP和UDP。

### Socket、HTTP、FTP

Socket是网络套接字，是对网络中不同主机的应用程序之间进行通信的端点的抽象，主要用于制作长连接（强联网）游戏。

HTTP是超文本传输协议，基于TCP，指定了客户端可能发送给服务端的信息内容以及得到的响应内容，主要用于制作弱联网游戏，也可用于资源下载。

FTP是文件传输协议，基于TCP，用于在网络上进行文件传输。

## IP地址和端口类

### IPAddress类

初始化IP信息的方式：

```C#
// 1. byte数组
byte[] ipAddress = new byte[] { 192, 168, 0, 1};
IPAddress ip1 = new IPAddress(ipAddress);

// 2. long
IPAddress ip2 = new IPAddress(0x79666F0B);

// 3. string
IPAddress ip3 = IPAddress.Parse("192.168.0.1");
```

### IPEndPoint类

初始化方式：

```C#
IPEndPoint ipep = new IPEndPoint(IPAddress.Parse("192.168.0.1"), 8080)
```

## 域名解析

域名是用来代替IP地址标识站点的，因为记忆一个IP地址通常比较困难，所以采用域名来代替IP地址。

域名解析就是将域名转换成IP地址，这个工作由DNS服务器完成。

域名系统是互联网的一项服务，它是一个将IP地址和域名相互映射的分布式数据库，能够更方便我们访问互联网。

### IPHostEntry类

该类是域名解析的返回值，其中包含了IP地址、主机名等信息。

- AddressList：关联的IP
- Aliases：主机别名列表
- HostName：DNS名称

### Dns类

```C#
// 1. 获取本地主机名称
var hostName = Dns.GetHostName();

// 2. 获取指定域名的IP信息
var entry = Dns.GetHostEntry("www.baidu.com"); // 同步方式
var entryAsync = await Dns.GetHostEntryAsync("www.baidu.com"); // 异步方式
```

## 序列化和反序列化二进制数据

在网络通信中，我们需要把对象序列化成二进制数据，再通过网络传输给远端设备，远端设备再将收到的二进制数据反序列化成相应的对象。

### 字符编码

因为计算机只能存储二进制数据，对于文字字符就需要转换成数字，而字符编码就是建立字符和数字之间对应关系的一种映射规则，例如在ASCII编码中用65来映射字符A。

常见的编码有ASCII（美国）、GB2312（中国）、Shift_JIS（日本），世界通用的编码是Unicode以及基于Unicode的编码，UTF-8、UTF-16、UTF-32。

乱码就是由于读写时所使用的编码不一致所造成的。

Unicode编码是为解决乱码问题而生的，它包含世界上的所有字符，每一个字符都对应一个唯一的二进制数。

但是Unicode编码只是一个符号集，只规定了字符与二进制的对应关系，没有规定二进制如何存储，因为一个字符可能只需要1个字节存储，也有可能需要2个字节存储。

UTF-8、UTF-16、UTF-32都是是基于Unicode的具体编码方案。

UTF-8根据实际情况使用1、2、3、4个字节来存储字符，UTF-16根据实际情况使用2、4个字节来存储字符，UTF-32固定用4个字节来存储字符。

### 序列化

#### 非字符串类型转字节数组

使用`BitConverter.GetBytes()`方法。

#### 字符串类型转字节数组

使用`Encoding.UTF8.GetBytes()`方法。

#### 类对象转字节数组

在网络通信中不能直接使用`BinaryFormatter`类，因为客户端和服务端使用的语言可能不一样，可能不兼容。

```C#
public class PlayerInfo
{
	public int level;
	public string name;
	public int attack;
	public bool sex;
	
	public byte[] GetBytes()
	{
		int indexNum = sizeof(int) + sizeof(int) + sizeof(string) + sizeof(int) + sizeof(bool); // string前面应该记录长度
		
		byte[] bytes = new byte[indexNum];
		int index = 0;
		
		BitConverter.GetBytes(level).CopyTo(bytes, index);
		index += sizeof(int);
		
		byte[] nameBytes = BitConverter.GetBytes(name);
		BitConverter.GetBytes(nameBytes.Length).CopyTo(bytes, index);
		index += sizeof(int);
		BitConverter.GetBytes(nameBytes).CopyTo(bytes, index);
		index += nameBytes.Length;
		
		BitConverter.GetBytes(attack).CopyTo(bytes, index);
		index += sizeof(int);
		
		BitConverter.GetBytes(sex).CopyTo(bytes, index);
		index += sizeof(bool);
		
		return bytes;
	}
}
```

### 反序列化

#### 字节数组转非字符串类型

使用`BitConverter.GetInt32()`等方法。

#### 字节数组转字符串类型

使用`Encoding.UTF8.GetString()`方法。

#### 二进制数据转类对象

```C#
public class PlayerInfo
{
	public int level;
	public string name;
	public int attack;
	public bool sex;
	
	public static PlayerInfo Get(byte[] bytes)
	{
		PlayerInfo info = new PlayerInfo();
		
		int index = 0;
		info.level = BitConverter.ToInt32(bytes, index);
		index += sizeof(int);
		
		int nameLength = BitConverter.ToInt32(bytes, index);
		index += sizeof(int);
		
		info.name = Encoding.UTF8.GetString(bytes, index, nameLength);
		index += nameLength;
		
		info.attack = BitConverter.ToInt32(bytes, index);
		index += sizeof(int);
		
		info.sex = BitConverter.ToBoolean(bytes, index);
		index += sizeof(bool);
		
		return info;
	}
}
```

## 套接字 Socket

Socket是用于TCP/IP网络通信的一个类，包含了通信双方的IP地址、端口和协议信息。

一个Socket对象表示一个本地或远程套接字信息，可视为一个数据通道，连接客户端与服务端。

一般在制作长连接游戏时，使用Socket套接字作为通信方案。

### 类型

1. 流套接字：实现TCP通信，提供面向连接、可靠有序、无差错、无重复的数据传输服务。
2. 数据包套接字：实现UDP通信，提供无连接的通信服务，数据包长度不超过32KB。
3. 原始套接字：实现IP数据包通信，用于直接访问协议的较低层，常用于侦听和分析数据包。

### 常用属性

- 连接状态：`Connected`
- 类型：`SocketType`
- 协议类型：`ProtocolType`
- 寻址方案：`AddressFamily`
- 从网络中准备读取的数据量：`Available`
- 本机EndPoint对象：`LocalEndPoint`
- 远程EndPoint对象：`RemoteEndPoint`

### 常用方法

> 主要用于服务端

- 绑定IP和端口：`Bind(IPEndPoint)`
- 设置客户端连接的最大数量：`Listen(int)`
- 等待客户端接入：`Accept()`

> 主要用于客户端

- 连接远程服务端：`Connect(IPAddress, int)`

> 客户端和服务端都会用的

- 同步发送和接受数据：`Send()`，`Receive()`
- 异步发送和接受数据：`BeginSend()`，`BeginReceive()`
- 释放连接并关闭Socket，先于Close调用：`Shutdown(SocketShutdown)`
- 关闭连接，释放所有Socket关联资源：`Close()`

### TCP 通信

#### 概述

> 客户端和服务端分别需要做什么

客户端：

1. 创建套接字
2. 使用Connect方法连接服务端
3. 使用Send和Reveive相关方法收发数据
4. 使用Shutdown方法释放连接
5. 关闭套接字

服务端：

1. 创建套接字
2. 使用Bind方法将套接字与本地地址绑定
3. 使用Listen方法监听
4. 使用Accept方法等待客户端连接
5. 建立连接，Accept返回新的套接字
6. 使用Send和Reveive相关方法收发数据
7. 使用Shutdown方法释放连接
8. 关闭套接字

## 分包和粘包

指的是在网络通信中由于各种原因（网络环境、API规则等）造成的消息与消息之间出现的两种状态。

分包就是一条消息分成了多条消息进行发送，粘包就是一条消息和另一条消息合并在一起进行发送，分包和粘包可能同时发生。

### 如何解决

在消息头部添加消息长度，接收到消息时通过消息长度判断是否分包、粘包，对消息进行拆分、合并处理。

## 心跳消息

在长连接中，客户端和服务端之间定期发送的一种特殊数据包，用于通知对方自己是否在线，以确保长连接的有效性。

### 为什么需要心跳消息

1. 避免服务端在非正常情况下关闭时，服务端无法收到断开连接的消息。
2. 避免客户端长时间不发送消息时，防火墙或路由器会自动断开连接，通过心跳消息保持活跃状态。

