---
tags:
  - Computer
  - Algorithm
date: 2023-09-07 10:15
---
## 递归
#### 爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

**递归解法：**

```CPP
class Solution {
public:
    int climbStairs(int n) {
        if(n == 2) return 2;
        if(n == 1) return 1;
        return climbStairs(n-1) + climbStairs(n-2);
    }
};
```

**哈希表解法：**

```CPP
class Solution {
public:
	int climbStairs(int n) {
		if(n==1) return 1;
		if(n==2) return 2;
		if(map.find(n) != map.end()) {
			return map[n];
		} else {
			int result = climbStairs(n-1) + climbStairs(n-2);
			map.emplace(n, result);
			return result;
		}
	}
	
private:
	unordered_map<int, int> map;
};
```

**循环解法：**

```CPP
class Solution {
public:
	int climbStairs(int n) {
		if(n==1) return 1;
		if(n==2) return 2;
		int p = 2, pp = 1, cur = 2;
		for(int i = 3; i <= n; i++) {
			cur = p + pp;
			pp = p;
			p = cur;
		}
		return cur;
	}
};
```

#### 斐波那契数列

写一个函数，输入 `n` ，求斐波那契（Fibonacci）数列的第 `n` 项（即 `F(N)`）。斐波那契数列的定义如下：
$$
F(0) = 0, F(1) = 1
$$
$$
F(N) = F(N - 1) + F(N - 2), 其中 N > 1.
$$

斐波那契数列由 0 和 1 开始，之后的斐波那契数就是由之前的两数相加而得出。

答案需要取模 *1e9+7（1000000007）*，如计算初始结果为：1000000008，请返回 1。

```CPP
class Solution {
public:
    int fib(int n) {
        if(n<=1) return n;
        int p = 1, pp = 0, result = 0;
        const int MAX = 1e9+7;
        for(int i = 2; i <= n; i++) {
            int temp = p + pp;
            result = temp > MAX ? temp%MAX : temp;
            pp = p;
            p = result;
        }
        return result;
    }
};
```

## 数组

#### 两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** `target`  的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

**哈希表解法：**

```CPP
class Solution {
public:
	vector<int> twoSum(vector<int>& nums, int target) {
		unordered_map<int, int> map;
		vector<int> result;
		for(int i = 0; i < nums.size(); i++) {
			int current = nums[i];
			// 字典中存在与current相加等于target的值
			if(map.find(target - current) != map.end()) {
				result.push_back(i);
				result.push_back(map[target - current]);
			}
			else
			{
				// 记录当前的值以及索引
				map.emplace(current, i);
			}
		}
		return result;
	}
};

/*更简洁的写法*/
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> dic;
        for(int i = 0; i < nums.size(); ++i) {
            if(dic.find(target-nums[i]) != dic.end()) {
                return {dic[target-nums[i]], i};
            }
            dic.emplace(nums[i], i);
        }
        return {};
    }
};
```

**双指针解法：**

#### 合并两个有序数组

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。

请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：** 最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

**使用双指针：**

```CPP
class Solution {
public:
	void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
		vector<int> temp;
		// 将nums1中的有效元素复制到temp中
		for(int i = 0; i < m; i++) {
			temp.push_back(nums1[i]);
		}
		
		int i = 0, j = 0, k = 0;
		while(i < m && j < n) {
			if(temp[i] <= nums2[j]) nums1[k++] = temp[i++];
			else nums1[k++] = nums2[j++];
		}
		
		// 若temp或nums2中还有剩余，则将剩余元素复制到nums中
		if(i < m) // nums1有剩余
			while(i < m) nums1[k++] = temp[i++];
		if(j < n) // nums2有剩余
			while(j < n) nums1[k++] = nums2[j++];
	}
};
```

**双指针优化：**

```CPP
class Solution {
public:
	void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
		/* 倒序合并，利用nums1空余空间，降低空间复杂度 */
		int i = m - 1, j = n - 1, k = m + n -1;
		while(i >= 0 && j >= 0) {
			if(nums1[i] > nums2[j]) nums1[k--] = nums1[i--];
			else nums1[k--] = nums2[j--];
		}
		
		// 处理剩余元素
		if(i >= 0) // nums1有剩余
			while(i >= 0) nums1[k--] = nums1[i--];
		if(j >= 0) // nums2有剩余
			while(j >= 0) nums1[k--] = nums2[j--];
	}
};
```

#### 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

**解法：**

```CPP
class Solution {
public:
	void moveZeroes(vector<int>& nums) {
		int i = 0, j = 0;
		while(i < nums.size()) {
			if(nums[i] != 0) swap(nums[i], nums[j++]);
			i++;
		}
		while(j < nums.size()) {
			nums[j++] = 0;
		}
	}
};
```

**双指针：**

```CPP
class Solution {
public:
    void moveZeroes(vector<int>& nums) {
        int left = 0, right = 0, n = nums.size();
        while(right < n) {
            if(nums[right] != 0) {
                swap(nums[left++], nums[right]);
            }
            right++;
        }
    }
};
```

#### 找到所有数组中消失的数字

给你一个含 `n` 个整数的数组 `nums` ，其中 `nums[i]` 在区间 `[1, n]` 内。请你找出所有在 `[1, n]` 范围内但没有出现在 `nums` 中的数字，并以数组的形式返回结果。

```CPP
class Solution {
public:
    vector<int> findDisappearedNumbers(vector<int>& nums) {
        int n = nums.size();
        /* 遍历数组，让数组中出现的每一个数的值作为下标对应的数加n */
        for(int num: nums) {
            int index = (num - 1) % n; // 还原数字
            nums[index] += n;
        }
        /* 第二次遍历数组，找到值小于等于n的元素，
        其下标加1就是未在数组中出现的数字 */
        vector<int> result;
        for(int i = 0; i < n; i++) {
            if(nums[i] <= n) result.push_back(i+1);
        }
        return result;
    }
};
```

#### 寻找文件副本

设备中存有 `n` 个文件，文件 `id` 记于数组 `documents`。若文件 `id` 相同，则定义为该文件存在副本。请返回任一存在副本的文件 `id`。

```CPP
class Solution {
public:
    int findRepeatDocument(vector<int>& documents) {
        int i = 0;
        while(i < documents.size()) {
            if(documents[i] != i) {
                if(documents[documents[i]] == documents[i])
                    return documents[i];
                else
                    swap(documents[i], documents[documents[i]]);
            } else {
                i++;
            }
        }
        return -1;
    }
};
```

#### 统计目标成绩的出现次数

某班级考试成绩按非严格递增顺序记录于整数数组 `scores`，请返回目标成绩 `target` 的出现次数。

```CPP
class Solution {
public:
    int countTarget(vector<int>& scores, int target) {
        int count = 0;
        int left = 0, right = scores.size() - 1, mid = -1;
        while(left <= right) {
            mid = (left + right) / 2;
            if(scores[mid] < target) left = mid + 1;
            else if(scores[mid] > target) right = mid - 1;
            else {
                ++count;
                break;
            }
        }
        for(left = mid - 1; left >= 0 && scores[left] == target; left--)
            count++;
        for(right = mid + 1; right < scores.size() && scores[right] == target; right++)
            count++;
        return count;
    }
};
```

```CPP
class Solution {
public:
    int search(vector<int>& nums, int target) {
        // 搜索右边界 right
        int i = 0, j = nums.size() - 1;
        while(i <= j) {
            int m = (i + j) / 2;
            if(nums[m] <= target) i = m + 1;
            else j = m - 1;
        }
        int right = i;
        // 若数组中无 target ，则提前返回
        if(j >= 0 && nums[j] != target) return 0;
        // 搜索左边界 right
        i = 0; j = nums.size() - 1;
        while(i <= j) {
            int m = (i + j) / 2;
            if(nums[m] < target) i = m + 1;
            else j = m - 1;
        }
        int left = j;
        return right - left - 1;
    }
};
```

#### 点名

某班级 n 位同学的学号为 0 ~ n-1。点名结果记录于升序数组 `record`。假定仅有一位同学缺席，请返回他的学号。

```CPP
class Solution {
public:
    int takeAttendance(vector<int>& record) {
        int left = 0, right = record.size() - 1;
        while(left <= right) {
            int mid = (left + right) / 2;
            if(record[mid] == mid) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return left;
    }
};
```

#### 数组中的第K个最大元素

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

```CPP
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        int target = nums.size() - k;
        int start = 0, end = nums.size() - 1;
        int index = partition(nums, start, end);
        while(index != target) {
            if(index < target) {
                start = index + 1;
            } else {
                end = index - 1;
            }
            index = partition(nums, start, end);
        }
        return nums[index];
    }
		    
    int partition(vector<int>& nums, int p, int r) {
        int pivot = nums[r];
        int i = p;
        for(int j = p; j < r; j++) {
            if(nums[j] < pivot) swap(nums[j], nums[i++]);
        }
        swap(nums[i], nums[r]);
        return i;
    }
};
```

#### 寻找目标值-二维数组

`m`*`n` 的二维数组 `plants` 记录了园林景观的植物排布情况，具有以下特性：

- 每行中，每棵植物的右侧相邻植物不矮于该植物；
- 每列中，每棵植物的下侧相邻植物不矮于该植物。

请判断 `plants` 中是否存在目标高度值 `target`。

```CPP
class Solution {
public:
    bool findTargetIn2DPlants(vector<vector<int>>& plants, int target) {
        if(plants.empty()) return false;
        int i = 0, j = plants[0].size() - 1;
        while(i < plants.size() && j >= 0) {
            if(plants[i][j] > target) j--;
            else if(plants[i][j] < target) i++;
            else return true;
        }
        return false;
    }
};
```

# 链表
#### 合并两个排序的链表

输入两个递增排序的链表，合并这两个链表并使新链表中的节点仍然是递增排序的。

**示例1：**

**输入：** 1->2->4, 1->3->4
**输出：** 1->1->2->3->4->4

**限制：**

`0 <= 链表长度 <= 1000`

**递归解法：**

```CPP
class Solution {
public:
	ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
		if(l1 == NULL) return l2;
		if(l2 == NULL) return l1;
		if(l1->val < l2->val) {
			l1->next = mergeTwoLists(l1->next, l2);
			return l1;
		} else {
			l2->next = mergeTwoLists(l2->next, l1);
			return l2;
		}
	}
};
```

**循环解法：**

```CPP
class Solution {
public:
	ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
		if(l1 == NULL) return l2;
		if(l2 == NULL) return l1;
		ListNode* resultNode = new ListNode(0);
		ListNode* p = resultNode;
		while(l1 != NULL && l2!= NULL) {
			if(l1->val < l2->val) {
				p->next = l1;
				l1 = l1->next;
			} else {
				p->next = l2;
				l2 = l2->next;
			}
			p = p->next;
		}
		if(l1 != NULL) p->next = l1;
		if(l2 != NULL) p->next = l2;
		return resultNode->next;
	}
};
```

#### 删除排序链表中的重复元素

给定一个已排序的链表的头 `head` ， _删除所有重复的元素，使每个元素只出现一次_ 。返回 _已排序的链表_ 。

```CPP
class Solution {
public:
	ListNode* deleteDuplicates(ListNode* head) {
		if(head == nullptr) return head;
		ListNode* currentNode = head;
		while(currentNode != nullptr && currentNode->next != nullptr) {
			if(currentNode->val == currentNode->next->val) {
			   currentNode->next = currentNode->next->next;
			} else {
				currentNode = currentNode->next;
			}
		}
		return head;
	}
};
```

#### 环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

_如果链表中存在环_ ，则返回 `true` 。 否则，返回 `false` 。

```CPP
class Solution {
public:
	bool hasCycle(ListNode *head) {
		if(head == NULL || head->next == NULL) return false;
		ListNode* slow = head;
		ListNode* fast = head;
		while(fast->next != NULL && fast->next->next != NULL) {
			slow = slow->next;
			fast = fast->next->next;
			if(slow == fast) return true;
		}
		return false;
	}
};
```

#### 环形链表Ⅱ

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 _如果链表无环，则返回 `null`。_

```CPP
class Solution {
public:
	ListNode *detectCycle(ListNode *head) {
		ListNode *slow = head, *fast = head;
		while (fast != nullptr) {
			slow = slow->next;
			if (fast->next == nullptr) {
				return nullptr;
			}
			fast = fast->next->next;
			if (fast == slow) {
				ListNode *ptr = head;
				while (ptr != slow) {
					ptr = ptr->next;
					slow = slow->next;
				}
				return ptr;
			}
		}
		return nullptr;
	}
};
```

#### 相交链表

给定两个单链表的头节点 `headA` 和 `headB` ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交：

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

**哈希集合解法：**

```CPP
class Solution {
public:
	ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
		unordered_set<ListNode *> set;
		ListNode *p = headA;
		while(p != NULL) {
			set.emplace(p);
			p = p->next;
		}
		p = headB;
		while(p != NULL) {
			if(set.find(p) != set.end()) return p;
			p = p->next;
		}
		return NULL;
	}
};
```

**双指针解法：**

1. 链表相交的情况：
	- 如果`a=b`，则两个指针会同时到达两个链表相交的节点，此时返回相交的节点；
	- 如果`a≠b`，设链表A和链表B的长度分别为m和n，链表A非相交部分长度为`a`，链表B非相交部分长度为`b`，相交部分长度为`c`。分别从头节点开始遍历两个链表，当遍历完链表A时将`pA`指针指向链表B的头节点，当遍历完链表B时将`pB`指针指向链表A的头节点。当pA指针的移动次数达到`a+c+b`时，pB指针的移动次数达到`b+c+a`时，两指针相遇，此时指向的就是相交的起始节点。
2. 链表不相交的情况：
	- 如果`m=n`，则两个指针会同时到达两个链表的尾节点，然后同时变成空值，此时返回null；
	- 如果`m≠n`，则由于两个链表没有公共节点，两个指针也不会同时到达两个链表的尾节点，因此两个指针都会遍历完两个链表，在指针`pA`移动了`m+n`次、指针`pB`移动了`n+m`次之后，两个指针会同时变成空值null，此时返回null。

```CPP
class Solution {
public:
	ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
		if(headA == NULL || headB == NULL) return NULL;
		ListNode *pA = headA, *pB = headB;
		while(pA != pB) {
			pA = pA == NULL ? headB : pA->next;
			pB = pB == NULL ? headA : pB->next;
		}
		return pA;
	}
};
```

#### 反转链表

定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。

**示例:**

**输入:** 1->2->3->4->5->NULL
**输出:** 5->4->3->2->1->NULL

**解法：**

```CPP
class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode *curNode = head, *preNode = NULL;
        while(curNode != NULL) {
            ListNode *nextNode = curNode->next;
            curNode->next = preNode;
            preNode = curNode;
            curNode = nextNode;
        }
        return preNode;
    }
};
```

#### 回文链表

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

**快慢指针+反转链表：**

1. 找到前半部分链表的尾节点。
2. 反转后半部分链表。
3. 判断是否回文。
4. 恢复链表。
5. 返回结果。

```CPP
class Solution {
public:
    bool isPalindrome(ListNode* head) {
        if (head == nullptr) {
            return true;
        }
        
        // 找到前半部分链表的尾节点并反转后半部分链表
        ListNode* firstHalfEnd = endOfFirstHalf(head);
        ListNode* secondHalfStart = reverseList(firstHalfEnd->next);
        
        // 判断是否回文
        ListNode* p1 = head;
        ListNode* p2 = secondHalfStart;
        bool result = true;
        while (result && p2 != nullptr) {
            if (p1->val != p2->val) {
                result = false;
            }
            p1 = p1->next;
            p2 = p2->next;
        }        
        
        // 还原链表并返回结果
        firstHalfEnd->next = reverseList(secondHalfStart);
        return result;
    }
    
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        while (curr != nullptr) {
            ListNode* nextTemp = curr->next;
            curr->next = prev;
            prev = curr;
            curr = nextTemp;
        }
        return prev;
    }
    
    ListNode* endOfFirstHalf(ListNode* head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while (fast->next != nullptr && fast->next->next != nullptr) {
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }
};
```

#### 链表的中间节点

给你单链表的头结点 `head` ，请你找出并返回链表的中间结点。

如果有两个中间结点，则返回第二个中间结点。

**快慢指针：**

```CPP
class Solution {
public:
    ListNode* middleNode(ListNode* head) {
        ListNode *slow = head, *fast = head;
        while(fast != nullptr && fast->next != nullptr) {
            slow = slow->next;
            fast = fast->next->next;
        }
        return slow;
    }
};
```

#### 链表中倒数第K个节点

输入一个链表，输出该链表中倒数第k个节点。为了符合大多数人的习惯，本题从1开始计数，即链表的尾节点是倒数第1个节点。

例如，一个链表有 `6` 个节点，从头节点开始，它们的值依次是 `1、2、3、4、5、6`。这个链表的倒数第 `3` 个节点是值为 `4` 的节点。

**示例：**

给定一个链表: **1->2->3->4->5**, 和 _k_ **= 2**.

返回链表 **4->5**.

```CPP
class Solution {
public:
    ListNode* getKthFromEnd(ListNode* head, int k) {
        if(head == nullptr) return head;
        ListNode *p1 = head;
        // p1先移动k-1次
        for(int i = 1; i < k; i++) {
            if(p1 != nullptr)
                p1 = p1->next;
        }
        ListNode *p2 = head;
        // p1和p2同时移动
        while(p1->next != nullptr) {
            p1 = p1->next;
            p2 = p2->next;
        }
        // 当p1移动到尾节点时，p2位于倒数第k个节点
        return p2;
    }
};
```

#### 随机链表的复制

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/%E6%B7%B1%E6%8B%B7%E8%B4%9D/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为  `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

```CPP
class Solution {
public:
    Node* copyRandomList(Node* head) {
        unordered_map<Node*, Node*> map;
        Node* cur = head;
        for(; cur != nullptr; cur = cur->next) {
            map.emplace(cur, new Node(cur->val));
        }
        for(cur = head; cur != nullptr; cur = cur->next) {
            map[cur]->next = map[cur->next];
            map[cur]->random = map[cur->random];
        }
        return map[head];
    }
};
```

#### 图书整理 Ⅰ

书店店员有一张链表形式的书单，每个节点代表一本书，节点中的值表示书的编号。为更方便整理书架，店员需要将书单倒过来排列，就可以从最后一本书开始整理，逐一将书放回到书架上。请倒序返回这个书单链表。

```CPP
class Solution {
public:
    vector<int> reverseBookList(ListNode* head) {
        vector<int> result;
        stack<int> stack;
        while(head) {
            stack.push(head->val);
            head = head->next;
        }
        while(!stack.empty()) {
            result.push_back(stack.top());
            stack.pop();
        }
        return result;
    }
};
```

# 栈和队列

#### 用两个栈实现队列

用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 `appendTail` 和 `deleteHead` ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，`deleteHead` 操作返回 -1 )

```CPP
class MyQueue {
public:
    MyQueue() {}
    
    void push(int x) {
	    // 直接将元素放入栈1
        stack1.push(x);
    }
    
    int pop() {
		// 若栈2为空，先将栈1元素放进栈2
        if(stack2.empty()) in2out();
        if(stack2.empty()) return -1;
        // 获取栈2栈顶元素即为队首元素
        int result = stack2.top();
        stack2.pop();
        return result;
    }
    
    int peek() {
	    // 若栈2为空，先将栈1元素放进栈2
        if(stack2.empty()) in2out();
        if(stack2.empty()) return -1;
        // 栈2栈顶元素为队首元素
        return stack2.top();
    }
    
    bool empty() {
        return stack1.empty() && stack2.empty();
    }
private:
    stack<int> stack1, stack2;
    
    void in2out() {
        while(!stack1.empty()) {
            stack2.push(stack1.top());
            stack1.pop();
        }
    }
};
```

#### 最小栈

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

```CPP
class MinStack {
public:
    MinStack() {
        minStack.push(INT_MAX);
    }
    
    void push(int val) {
        dataStack.push(val);
        minStack.push(min(val, minStack.top()));
    }
    
    void pop() {
        dataStack.pop();
        minStack.pop();
    }
    
    int top() {
        return dataStack.top();
    }
    
    int getMin() {
        return minStack.top();
    }
    
private:
    stack<int> dataStack, minStack;
};
```

#### 字符串解码

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

```CPP
class Solution {
public:
	string decodeString(string s) {
		vector<string> stack;
		int ptr = 0;
		while(ptr < s.size()) {
			char cur = s[ptr];
			// 处理数字
			if(isdigit(cur)) {
				string numStr = "";
				while(isdigit(s[ptr]))
					numStr += s[ptr++];
				stack.push_back(numStr);
			}
			// 字母和左括号
			else if(isalpha(cur) || cur == '[') {
				stack.push_back(string(1, s[ptr++]));
			}
			// 右括号
			else {
				ptr++;
				vector<string> sub;
				// 取出倒序的子序列
				while(stack.back() != "[") {
					sub.push_back(stack.back());
					stack.pop_back();
				}
				// 反转序列
				reverse(sub.begin(), sub.end());
				// 取出重复次数
				stack.pop_back(); // 弹出左括号
				int repeatTimes = stoi(stack.back());
				stack.pop_back();
				// 获取重复的子序列并压入栈中
				stack.push_back(repeatStr(linkStr(sub), repeatTimes));
			}
		}
		return linkStr(stack);
	}

private:
	string repeatStr(string str, int times) {
		string result = "";
		for(int i = 0; i < times; i++)
			result += str;
		return result;
	}
	
	string linkStr(vector<string> &strs) {
		string result = "";
		for(string str: strs)
			result += str;
		return result;
	}
};
```

# 树

#### 二叉树的中序遍历

给定一个二叉树的根节点 `root` ，返回 _它的 **中序** 遍历_ 。

**递归：**

```CPP
class Solution {
public:
	vector<int> inorderTraversal(TreeNode* root) {
		vector<int> result;
		accessTreeNode(root, result);
		return result;
	}
	
	void accessTreeNode(TreeNode *root, vector<int> &storage) {
		if(root == nullptr) return;
		accessTreeNode(root->left, storage);
		storage.push_back(root->val);
		accessTreeNode(root->right, storage);
	}
};
```

**栈循环：**

```CPP
class Solution {
public:
	vector<int> inorderTraversal(TreeNode* root) {
		vector<int> result; // 保存遍历结果的数组
		stack<TreeNode*> stack; // 用于辅助遍历的栈
		while(root != nullptr || !stack.empty()) {
			// 查找当前节点的所有左子节点
			while(root != nullptr) {
				stack.push(root);
				root = root->left;
			}
			// 取出栈顶节点
			TreeNode* node = stack.top();
			stack.pop();
			// 将当前节点存入结果
			result.push_back(node->val);
			// 遍历右子节点
			root = node->right;
		}
		return result;
	}
};
```

#### 二叉树的前序遍历

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

```CPP
class Solution {
public:
	vector<int> preorderTraversal(TreeNode* root) {
		vector<int> result;
		stack<TreeNode*> stack;
		while(root != nullptr || !stack.empty()) {
			while(root != nullptr) {
				result.push_back(root->val);
				stack.push(root);
				root = root->left;
			}
			root = stack.top();
			stack.pop();
			root = root->right;
		}
		return result;
	}
};
```

#### 二叉树的后序遍历

给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。

```CPP
class Solution {
public:
	vector<int> postorderTraversal(TreeNode* root) {
		vector<int> result;
		stack<TreeNode*> stack;
		TreeNode *preAccess;
		while(root != nullptr || !stack.empty()) {
			while(root != nullptr) {
				stack.push(root);
				root = root->left;
			}
			root = stack.top();
			stack.pop();
			if(root->right == nullptr || root->right == preAccess) {
				result.push_back(root->val);
				preAccess = root;
				root = nullptr;
			} else {
				stack.push(root);
				root = root->right;
			}
		}
		return result;
	}
};
```

#### 对称二叉树

请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。

**递归解法：**

```CPP
class Solution {
public:
	bool isSymmetric(TreeNode* root) {
		if(root == nullptr) return true;
		return deepCheck(root->left, root->right);
	}
	
private:
	bool deepCheck(TreeNode *left, TreeNode *right) {
		if(left == nullptr && right == nullptr) return true;
		if(left == nullptr || right == nullptr) return false;
		if(left->val != right->val) return false;
		
		return deepCheck(left->left, right->right)
			&& deepCheck(right->right, right->left);
	}
};
```

**队列+循环解法：**

```CPP
class Solution {
public:
	bool isSymmetric(TreeNode* root) {
		if(root == nullptr) return true;
		TreeNode *u = root->left, *v = root->right;
		if(u == nullptr && v == nullptr) return true;
		queue<TreeNode*> queue;
		queue.push(u);
		queue.push(v);
		while(!queue.empty()){
			u = queue.front();
			queue.pop();
			v = queue.front();
			queue.pop();
			if(u == nullptr && v == nullptr)
				continue;
			if((u == nullptr || v == nullptr) || (u->val != v->val))
				return false;
			queue.push(u->left);
			queue.push(v->right);
			queue.push(u->right);
			queue.push(v->left);
		}
		return true;
	}
};
```

#### 二叉树的深度

输入一棵二叉树的根节点，求该树的深度。从根节点到叶节点依次经过的节点（含根、叶节点）形成树的一条路径，最长路径的长度为树的深度。

**队列+循环解法：**

```CPP
class Solution {
public:
	int maxDepth(TreeNode* root) {
		if(root == nullptr) return 0;
		queue<TreeNode*> queue;
		queue.push(root);
		int depth = 0;
		while(!queue.empty()) {
			int size = queue.size();
			while(size > 0) {
				TreeNode *node = queue.front();
				queue.pop();
				if(node->left != nullptr)
					queue.push(node->left);
				if(node->right != nullptr)
					queue.push(node->right);
				size--;
			}
			depth++;
		}
		return depth;
	}
};
```

#### 平衡二叉树

输入一棵二叉树的根节点，判断该树是不是平衡二叉树。如果某二叉树中任意节点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。

```CPP
class Solution {
public:
	bool isBalanced(TreeNode* root) {
		return height(root) >= 0;
	}
	
private:
	int height(TreeNode* root) {
		if(root == nullptr) return 0;
		int leftHeight = height(root->left);
		int rightHeight = height(root->right);
		if(leftHeight == -1 || rightHeight == -1 || 
			abs(leftHeight - rightHeight) > 1)
			return -1;
		else
			return max(leftHeight, rightHeight) + 1;
	}
};
```

#### 翻转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

```CPP
class Solution {
public:
	TreeNode* invertTree(TreeNode* root) {
		if(root == nullptr) return nullptr;
		invertTree(root->left);
		invertTree(root->right);
		TreeNode *temp = root->left;
		root->left = root->right;
		root->right = temp;
		return root;
	}
};
```

#### 二叉树广度优先搜索

```CPP
vector<int> bfs(TreeNode* root) {
	vector<int> result;
	queue<TreeNode*> queue;
	if(root) queue.push(root);
	while(!queue.empty()) {
		TreeNode* node = queue.front();
		queue.pop();
		result.push_back(node->val);
		if(node->left) queue.push(node->left);
		if(node->right) queue.push(node->right);
	}
	return result;
}
```

#### 二叉树中每层的最大值

给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

**单队列：**

```CPP
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> result;
        queue<TreeNode*> queue;
        // current代表当前层未遍历的节点数
        // next代表下一层的节点数
        int current = 0, next = 0;
        if(root) {
            queue.push(root);
            current++;
        }
        int max = INT_MIN; // 记录每一层的最大值
        while(!queue.empty()) {
            TreeNode* node = queue.front();
            queue.pop();
            current--;
            // 更新最大值
            max = node->val > max ? node->val : max;
            // 加入左右子节点
            if(node->left){
                queue.push(node->left);
                next++;
            }
            if(node->right) {
                queue.push(node->right);
                next++;
            }
            // 遍历完一层，将最大值加入结果
            // 交换current和next的值
            if(current == 0) {
                result.push_back(max);
                max = INT_MIN;
                current = next;
                next = 0;
            }
        }
        return result;
    }
};
```

**双队列：**

```CPP
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        vector<int> result;
        queue<TreeNode*> queue1;
        queue<TreeNode*> queue2;
        if(root) queue1.push(root);
        int max = INT_MIN;
        while(!queue1.empty()) {
            TreeNode* node = queue1.front();
            queue1.pop();
            max = node->val > max ? node->val : max;
            if(node->left) queue2.push(node->left);
            if(node->right) queue2.push(node->right);
            if(queue1.empty()) {
                queue1 = queue2;
                queue2 = queue<TreeNode*>();
                result.push_back(max);
                max = INT_MIN;
            }
        }
        return result;
    }
};
```

#### 二叉树最底层最左边的值

给定一个二叉树的 **根节点** `root`，请找出该二叉树的 **最底层 最左边** 节点的值。

假设二叉树中至少有一个节点。

```CPP
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        queue<TreeNode*> queue1, queue2;
        queue1.push(root);
        int bottomLeft = root->val;
        while(!queue1.empty()) {
            TreeNode* node = queue1.front();
            queue1.pop();
            if(node->left) queue2.push(node->left);
            if(node->right) queue2.push(node->right);
            if(queue1.empty()) {
                queue1 = queue2;
                queue2 = queue<TreeNode*>();
                if(!queue1.empty()) {
                    bottomLeft = queue1.front()->val;
                }
            }
        }
        return bottomLeft;
    }
};
```

#### 二叉树剪枝

给定一个二叉树 **根节点** `root` ，树的每个节点的值要么是 `0`，要么是 `1`。请剪除该二叉树中所有节点的值为 `0` 的子树。

节点 `node` 的子树为 `node` 本身，以及所有 `node` 的后代。

```CPP
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        if (!root) return nullptr;
        root->left = pruneTree(root->left);
        root->right = pruneTree(root->right);
        if (!root->left && !root->right && !root->val) return nullptr;
        return root;
    }   
};
```

#### 在完全二叉树中添加节点

完全二叉树是每一层（除最后一层外）都是完全填充（即，节点数达到最大，第 `n` 层有 `2n-1` 个节点）的，并且所有的节点都尽可能地集中在左侧。

设计一个用完全二叉树初始化的数据结构 `CBTInserter`，它支持以下几种操作：

- `CBTInserter(TreeNode root)` 使用根节点为 `root` 的给定树初始化该数据结构；
- `CBTInserter.insert(int v)`  向树中插入一个新节点，节点类型为 `TreeNode`，值为 `v` 。使树保持完全二叉树的状态，**并返回插入的新节点的父节点的值**；
- `CBTInserter.get_root()` 将返回树的根节点。

```CPP
class CBTInserter {
public:
    CBTInserter(TreeNode* root) {
        _root = root;
        queue.push(root);
        while(queue.front()->left && queue.front()->right) {
            TreeNode* front = queue.front();
            queue.pop();
            queue.push(front->left);
            queue.push(front->right);
        }
    }
    
    int insert(int v) {
        TreeNode* node = new TreeNode(v);
        TreeNode* front = queue.front();
        if(!front->left) {
            front->left = node;
        } else {
            front->right = node;
            queue.pop();
            queue.push(front->left);
            queue.push(front->right);
        }
        return front->val;
    }
    
    TreeNode* get_root() {
        return _root;
    }
private:
    TreeNode* _root;
    queue<TreeNode*> queue;
};
```

# 图

#### 最大的岛屿面积

给你一个大小为 `m x n` 的二进制矩阵 `grid` 。

**岛屿** 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在 **水平或者竖直的四个方向上** 相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。

岛屿的面积是岛上值为 `1` 的单元格的数目。

计算并返回 `grid` 中最大的岛屿面积。如果没有岛屿，则返回面积为 `0` 。

```CPP
class Solution {  
public:  
    int maxAreaOfIsland(vector<vector<int>> &grid) {  
        int rows = grid.size();  
        int columns = grid[0].size();  
        vector<vector<bool>> visited(rows, vector<bool>(columns, false));  
        int maxArea = 0;  
        for (int i = 0; i < rows; i++) {  
            for (int j = 0; j < columns; j++) {  
                if (visited[i][j] || grid[i][j] != 1) continue;  
                int area = getArea(grid, visited, i, j);  
                maxArea = max(maxArea, area);  
            }  
        }  
        return maxArea;  
    }  
    
    int getArea(vector<vector<int>> &grid, vector<vector<bool>> &visited,  
                int i, int j) {  
        clearQueue();  
        queue.push({i, j});  
        visited[i][j] = true;  
        int area = 0;  
        while (!queue.empty()) {  
            vector<int> position = queue.front();  
            queue.pop();  
            area++;  
            for (vector<int> dir: dirs) {  
                int row = position[0] + dir[0];  
                int column = position[1] + dir[1];  
                if (row >= 0 && row < grid.size()  
                    && column >= 0 && column < grid[0].size()  
                    && !visited[row][column] && grid[row][column] == 1) {  
                    queue.push({row, column});  
                    visited[row][column] = true;  
                }  
            }  
        }  
        return area;  
    }  
    
    void clearQueue() {  
        while (!queue.empty()) queue.pop();  
    }  
    
private:  
    queue<vector<int>> queue;  
    vector<vector<int>> dirs = {{-1, 0},{0,  1},{1,  0},{0,  -1}};  
};
```

**内存优化，取消visited数组：**

```CPP
class Solution {  
public:  
    int maxAreaOfIsland(vector<vector<int>> &grid) {  
        int rows = grid.size();  
        int columns = grid[0].size();  
        int maxArea = 0;  
        for (int i = 0; i < rows; i++) {  
            for (int j = 0; j < columns; j++) {  
                if (grid[i][j] != 1) continue;  
                int area = getArea(grid, i, j);  
                maxArea = max(maxArea, area);  
            }  
        }  
        return maxArea;  
    }  
    
    int getArea(vector<vector<int>> &grid, int i, int j) {  
        clearQueue();  
        queue.push({i, j});  
        grid[i][j] = -1;  
        int area = 0;  
        while (!queue.empty()) {  
            vector<int> position = queue.front();  
            queue.pop();  
            area++;  
            for (vector<int> dir: dirs) {  
                int row = position[0] + dir[0];  
                int column = position[1] + dir[1];  
                if (row >= 0 && row < grid.size()  
                    && column >= 0 && column < grid[0].size()  
                    && grid[row][column] == 1) {  
                    queue.push({row, column});  
                    grid[row][column] = -1;  
                }  
            }  
        }  
        return area;  
    }  
    
    void clearQueue() {  
        while (!queue.empty()) queue.pop();  
    }  
    
private:  
    queue<vector<int>> queue;  
    vector<vector<int>> dirs = {{-1, 0}, {0,  1}, {1,  0}, {0,  -1}};  
};
```

# 二分查找

#### 查找插入的位置

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 `O(log n)` 的算法。

```CPP
class Solution {
public:
	int searchInsert(vector<int>& nums, int target) {
		int left = 0, right = nums.size() - 1;
		while(left <= right) {
			int mid = (left + right) / 2;
			if(nums[mid] >= target) {
				if(mid == 0 || nums[mid - 1] < target)
					return mid;
				right = mid - 1;
			} else {
				left = mid + 1;
			}
		}
		return nums.size();
	}
};
```

# 哈希表

#### 插入、删除和随机访问都是$O(1)$的容器

设计一个支持在*平均时间复杂度* **O(1)** 下，执行以下操作的数据结构：

- `insert(val)`：当元素 `val` 不存在时返回 `true` ，并向集合中插入该项，否则返回 `false` 。
- `remove(val)`：当元素 `val` 存在时返回 `true` ，并从集合中移除该项，否则返回 `false` 。
- `getRandom`：随机返回现有集合中的一项。每个元素应该有 **相同的概率** 被返回。

**示例 :**

**输入:** inputs = ["RandomizedSet", "insert", "remove", "insert", "getRandom", "remove", "insert", "getRandom"]
[[], [1], [2], [2], [], [1], [2], []]

**输出:** [null, true, false, true, 2, true, false, 2]

**解释:**

```CPP
RandomizedSet randomSet = new RandomizedSet();  // 初始化一个空的集合

randomSet.insert(1); // 向集合中插入 1 ， 返回 true 表示 1 被成功地插入

randomSet.remove(2); // 返回 false，表示集合中不存在 2 

randomSet.insert(2); // 向集合中插入 2 返回 true ，集合现在包含 [1,2] 

randomSet.getRandom(); // getRandom 应随机返回 1 或 2 
  
randomSet.remove(1); // 从集合中移除 1 返回 true 。集合现在包含 [2] 

randomSet.insert(2); // 2 已在集合中，所以返回 false 

randomSet.getRandom(); // 由于 2 是集合中唯一的数字，getRandom 总是返回 2 
```

**提示：**

- `-231 <= val <= 231 - 1`
- 最多进行 `2 * 105` 次 `insert` ， `remove` 和 `getRandom` 方法调用
- 当调用 `getRandom` 方法时，集合中至少有一个元素

```CPP
class RandomizedSet {
public:

    /** Initialize your data structure here. */
    RandomizedSet() {}

    /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */
    bool insert(int val) {
        //如果插入的元素已经存在了，返回false
        if(numToLoc.find(val) != numToLoc.end()) return false;
        //添加到哈希表中
        numToLoc.emplace(val, nums.size());
        //添加到数组中
        nums.push_back(val);
        return true;
    }

    /** Removes a value from the set. Returns true if the set contained the specified element. */
    bool remove(int val) {
        //如果移除的元素不存在，返回false
        if(numToLoc.find(val) == numToLoc.end()) return false;
        //根据哈希表得到元素在数组中的位置
        int loc = numToLoc[val];
        //修改哈希表
        numToLoc[nums[nums.size()-1]] = loc;
        //将要移除的元素和最后一个元素交换位置
        swap(nums[nums.size()-1], nums[loc]);
        //nums[loc] = nums[nums.size()-1]; //或直接将删除位置的元素替换为最后一个元素
        //从哈希表中移除
        numToLoc.erase(val);
        //移除数组最后一个元素
        nums.pop_back();
        return true;
    }

    /** Get a random element from the set. */
    int getRandom() {
        int random = rand() % nums.size();
        return nums[random];
    }

private:
    unordered_map<int, int> numToLoc;
    vector<int> nums;
    
};
```

#### LRU缓存

请你设计并实现一个满足  [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

```CPP
struct LinkedNode {  
    int key;  
    int value;  
    LinkedNode *prev;  
    LinkedNode *next;  
    
    LinkedNode(int key, int value) {  
        this->key = key;  
        this->value = value;  
        this->prev = nullptr;  
        this->next = nullptr;  
    }  
};  

class LRUCache {  
public:  
    explicit LRUCache(int capacity) {  
        this->capacity = capacity;  
        this->head = new LinkedNode(-1, -1);  
        this->tail = new LinkedNode(-1, -1);  
        head->next = tail;  
        tail->prev = head;  
    }  
    
    int get(int key) {  
        auto iterator = map.find(key);  
        if (map.empty() || iterator == map.end()) return -1;  
        auto node = iterator->second;  
        moveToTail(node);  
        return node->value;  
    }  
    
    void put(int key, int value) {  
        auto iterator = map.find(key);  
        // key已存在  
        if (iterator != map.end()) {  
            auto node = iterator->second;  
            // 修改节点值，并移动到链表尾部  
            node->value = value;  
            moveToTail(node);  
        }  
        else {  
            // 若空间不足，先删除最近最少使用的元素  
            if (map.size() == capacity) {  
                auto node = head->next;  
                map.erase(node->key);  
                deleteNode(node);  
            }  
            // 添加新元素  
            auto newNode = new LinkedNode(key, value);  
            insertToTail(newNode);  
            map.emplace(key, newNode);  
        }  
    }  
    
private:  
    int capacity;  
    
    unordered_map<int, LinkedNode *> map;  
    LinkedNode *head;  
    LinkedNode *tail;  
    
    void moveToTail(LinkedNode *node) {  
        auto newNode = new LinkedNode(node->key, node->value);  
        map[node->key] = newNode;  
        deleteNode(node);  
        insertToTail(newNode);  
    }  
    
    void insertToTail(LinkedNode *node) {  
        tail->prev->next = node;  
        node->prev = tail->prev;  
        node->next = tail;  
        tail->prev = node;  
    }  
    
    void deleteNode(LinkedNode *node) {  
        node->prev->next = node->next;  
        node->next->prev = node->prev;  
    }  
};
```

# 字符串

#### 比较版本号

给你两个版本号 `version1` 和 `version2` ，请你比较它们。

版本号由一个或多个修订号组成，各修订号由一个 `'.'` 连接。每个修订号由 **多位数字** 组成，可能包含 **前导零** 。每个版本号至少包含一个字符。修订号从左到右编号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，`2.5.33` 和 `0.1` 都是有效的版本号。

比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 **忽略任何前导零后的整数值** 。也就是说，修订号 `1` 和修订号 `001` **相等** 。如果版本号没有指定某个下标处的修订号，则该修订号视为 `0` 。例如，版本 `1.0` 小于版本 `1.1` ，因为它们下标为 `0` 的修订号相同，而下标为 `1` 的修订号分别为 `0` 和 `1` ，`0 < 1` 。

返回规则如下：

- 如果 `_version1_ > _version2_` 返回 `1`，
- 如果 `_version1_ < _version2_` 返回 `-1`，
- 除此之外返回 `0`。

```CPP
class Solution {
public:
    int compareVersion(string version1, string version2) {
        size_t m = version1.size();
        size_t n = version2.size();
        int i = 0, j = 0;
        while(i < m || j < n) {
            int x = 0, y = 0;
            for(; i < m && version1[i] != '.'; ++i) {
                x = x * 10 + (version1[i] - '0');
            }
            ++i;
            for(; j < n && version2[j] != '.'; ++j) {
                y = y * 10 + (version2[j] - '0');
            }
            ++j;
            if(x != y) return x < y ? -1 : 1;
        }
        return 0;
    }
};
```

#### 找到字符串中所有的字母异位词

给定两个字符串 `s` 和 `p`，找到 `s` 中所有 `p` 的 **异位词** 的子串，返回这些子串的起始索引。不考虑答案输出的顺序。

**异位词** 指由相同字母重排列形成的字符串（包括相同的字符串）。

```CPP
class Solution {
public:
    vector<int> findAnagrams(string s, string p) {
        if(p.size() > s.size()) return {};
        vector<int> result;
        vector<int> dict(26, 0);
        for (int i = 0; i < p.size(); i++) {
            dict[p[i] - 'a']++;
            dict[s[i] - 'a']--;
        }
        if (isAllZero(dict)) result.push_back(0);
        for (int i = p.size(); i < s.size(); i++) {
            dict[s[i - p.size()] - 'a']++;
            dict[s[i] - 'a']--;
            if (isAllZero(dict))
                result.push_back(i - p.size() + 1);
        }
        
        return result;
    }
    
    bool isAllZero(vector<int> &counts) {
        for (int &count: counts)
            if (count != 0) return false;
        return true;
    }
};
```

#### 字母异位词分组

给你一个字符串数组，请你将 **字母异位词** 组合在一起。可以按任意顺序返回结果列表。

**字母异位词** 是由重新排列源单词的所有字母得到的一个新单词。

```CPP
class Solution {  
public:  
    vector<vector<string>> groupAnagrams(vector<string> &strs) {  
        vector<vector<string>> result;  
        unordered_map<string, vector<string>> map;  
        for (int i = 0; i < strs.size(); ++i) {  
            string str = strs[i];  
            sort(str.begin(), str.end());  
            if (map.find(str) != map.end()) {  
                map[str].push_back(strs[i]);  
            } else {  
                vector<string> group = {strs[i]};  
                map.emplace(str, group);  
            }  
        }  
        for(const auto &pair: map) {  
            result.push_back(pair.second);  
        }  
        return result;  
    }  
};
```

#### 有效的回文

给定一个字符串，请判断它是否回文。假设只需要考虑字母和数字字符，并忽略大小写。例如，“Was it a cat I saw?” 是一个回文字符串，而“race a car”不是回文字符串。

```CPP
bool isPalindrome(string s) {  
    for (int i = 0, j = s.size() - 1; i < j;) {  
        char l = s[i];  
        char r = s[j];  
        if (!isalnum(l)) i++;  
        else if (!isalnum(r)) j--;  
        else if (tolower(l) != tolower(r)) return false;  
        else ++i, --j;  
    }  
    return true;  
}
```

#### 最多删除一个字符得到回文

给定一个字符串，请判断如果最多从字符串中删除一个字符能不能得到一个回文字符串，例如，如果输入字符串“abca”，由于删除字符'b'或'c'就能得到一个回文字符串，因此输出为true。

```CPP
bool isPalindrome(string s, int start, int end) {  
    while(start < end) {  
        if(s[start] != s[end]) break;  
        ++start, --end;  
    }  
    return start >= end;  
}  
  
// 最多删除一个字符得到回文  
bool validPalindrome(string s) {  
    int start = 0, end = s.size() - 1;  
    for (; start < s.size() / 2; ++start, --end) {  
        if (s[start] != s[end]) break;  
    }  
    return start == s.size() / 2  
           || isPalindrome(s, start, end - 1)  
           || isPalindrome(s, start + 1, end);  
}
```

#### 回文子字符串的个数

给定一个字符串，请问该字符串中有多少个回文连续子字符串？例如，字符串“abc”由3个回文字符串，而字符串“aaa”由6个回文字符串。

```CPP 
int countPalindrome(string s, int start, int end) {  
    int count = 0;  
    while (start >= 0 && end < s.size() && s[start] == s[end]) {  
        ++count;  
        --start;  
        ++end;  
    }  
    return count;  
}  
  
int countSubStrings(string s) {  
    if (s.length() == 0) return 0;  
    int count = 0;  
    for (int i = 0; i < s.size(); ++i) {  
        count += countPalindrome(s, i, i);  
        count += countPalindrome(s, i, i + 1);  
    }  
    return count;  
}
```

# 排序算法

**常用排序算法对比：**

| |是原地排序？|是稳定排序？|平均时间复杂度|
|---|---|---|---|
|冒泡排序|是|是|$O(n^2)$|
|插入排序|是|是|$O(n^2)$|
|选择排序|是|否|$O(n^2)$|
|快速排序|是|否|$O(nlogn)$|
|归并排序|否|是|$O(nlogn)$|
|桶排序|否|是|$O(n+k)$，k为数据规模|
|计数排序|否|是|$O(n)$|
|基数排序|否|是|$O(n)$，d为数据维度|

#### 冒泡排序

冒泡排序算法的原理如下：

1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。
4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。

整个冒泡排序过程包含多次冒泡操作。每一次冒泡操作都会遍历整个数组，依次对数组中相邻的元素进行比较，看是否满足大小关系要求，如果不满足，就将它们互换位置。一次冒泡操作会让至少一个元素移动到它应该在的位置，重复n次，就完成了n个数据的排序工作。

代码实现如下：

```CPP
void BubbleSort(vector<int> &nums)
{
	if (nums.size() == 0)
		return;
	for (int i = 0; i < nums.size(); i++)
	{
		bool swapped = false;
		for (int j = 0; j < nums.size() - i - 1; j++)
		{
			if (nums[j + 1] < nums[j])
			{
				int temp = nums[j];
				nums[j] = nums[j + 1];
				nums[j + 1] = temp;
				swapped = true;
			}
		}
		if (!swapped)
			break;
	}
}
```

#### 选择排序

选择排序是一种简单直观的排序算法。它的工作原理是：第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。以此类推，直到全部待排序的数据元素的个数为零。选择排序是不稳定的排序方法。

```CPP
void SelectionSort(vector<int> &nums)
{
    if (nums.size() == 0)
        return;
    for (int i = 0; i < nums.size() - 1; i++)
    {
        int minIndex = i;
        for (int j = i + 1; j < nums.size(); j++)
            if (nums[j] < nums[minIndex])
                minIndex = j;
        int temp = nums[i];
        nums[i] = nums[minIndex];
        nums[minIndex] = temp;
    }
}
```

#### 插入排序

插入排序是指在待排序的元素中，假设前面n-1(其中n>=2)个数已经是排好顺序的，现将第n个数插到前面已经排好的序列中，然后找到合适自己的位置，使得插入第n个数的这个序列也是排好顺序的。按照此法对所有元素进行插入，直到整个序列排为有序的过程，称为插入排序 。

```CPP
void InsertionSort(vector<int> &nums)
{
    if (nums.size() == 0)
        return;
    for (int i = 1; i < nums.size(); i++)
    {
        int current = nums[i];
        int j = i;
        for (; j > 0 && nums[j - 1] > current; j--)
            nums[j] = nums[j - 1];
        nums[j] = current;
    }
}
```

#### 希尔排序

希尔排序的基本思想是将待排序的序列划分为若干个子序列，对每个子序列进行直接插入排序。具体来说，希尔排序首先取一个增量n，将待排序序列按照增量n划分为一个个小序列，每个小序列使用直接插入排序。然后增量递减，每个小序列变大，继续进行直接插入排序，直到增量递减为1，最后对整个序列进行一次直接插入排序。

希尔排序的性能大部分取决于增量序列的选择。对于希尔排序的增量序列，常见的选择有希尔原始的增量序列和Hibbard增量序列。原始的希尔增量序列是n/2, n/4, n/8, ..., 1，Hibbard增量序列是1, 3, 7, ..., 2^k - 1。

使用原始希尔增量序列：

```CPP
void ShellSort(vector<int> &nums)
{
    for (int gap = nums.size() / 2; gap > 0; gap /= 2)
    {
        for (int i = gap; i < nums.size(); i++)
        {
            int current = nums[i];
            int j = i;
            for (; j >= gap && nums[j - gap] > current; j -= gap)
                nums[j] = nums[j - gap];
            nums[j] = current;
        }
    }
}
```

使用Hibbard增量序列：

```CPP
void shellSort(vector<int> &nums) {  
    for (int gap = 1; gap < nums.size(); gap = 2 * gap + 1) {  
        for (int i = gap; i < nums.size(); ++i) {  
            int current = arr[i];  
            int j = i;  
            for (; j >= gap && arr[j - gap] > current; j -= gap) {  
                nums[j] = nums[j - gap];  
            }
            nums[j] = current;  
        }  
    }  
} 
```

#### 快速排序

快速排序采用的是分治思想，即在一个无序的序列中选取一个任意的基准元素pivot，利用pivot将待排序的序列分成两部分，前面部分元素均小于或等于基准元素，后面部分均大于或等于基准元素，然后采用递归的方法分别对前后两部分重复上述操作，直到将无序序列排列成有序序列。

```CPP
/// @brief 快速排序原地分区函数
/// @param nums 
/// @param p 
/// @param r 
/// @return 
int Partition(vector<int> &nums, int p, int r)
{
    int pivot = nums[r]; // 选取最后一个元素作为基准值
    int i = p;
    for (int j = p; j < r; j++)
        // 将小于基准值的元素移动到左边
        // i最后会停留到序列中第一个大于基准值的元素的位置
        if (nums[j] < pivot)
            swap(nums[i++], nums[j]);
    swap(nums[i], nums[r]); // 移动基准值，使左边元素均小于基准值，右边元素均大于基准值
	    return i;
}

/// @brief 快速排序递归函数
/// @param nums 
/// @param p 
/// @param r 
void QuickSortR(vector<int> &nums, int p, int r)
{
    if (p >= r)
        return;
    int q = Partition(nums, p, r);
    QuickSortR(nums, p, q - 1);
    QuickSortR(nums, q + 1, r);
}

void QuickSort(vector<int> &nums)
{
    QuickSortR(nums, 0, nums.size() - 1);
}
```

**另一个版本：**

```CPP
void quick_sort(vector<int> &a, int l, int r)
{
    if (l >= r)
        return;
    int i = l, j = r, x = a[i];
    while (i < j)
    {
        while (i < j && a[j] > x) // 从右向左找第一个小于x的数
            j--;
        if (i < j)
            a[i++] = a[j];
        while (i < j && a[i] < x) // 从左向右找第一个大于x的数
            i++;
        if (i < j)
            a[j--] = a[i];
    }
    a[i] = x;
    quick_sort(a, l, i - 1); // 递归调用
    quick_sort(a, i + 1, r); // 递归调用
}
```

#### 归并排序

归并排序（Merge Sort）是一种基于分治思想的排序算法，它的基本思路是将待排序序列分为若干个子序列，对每个子序列进行排序，最后将有序的子序列合并为整体有序序列。

归并排序的具体实现过程如下：

1. 将待排序序列平均分成两个子序列，每个子序列的长度为原序列长度的一半。
2. 对每个子序列递归地调用归并排序，直到子序列的长度为1。
3. 将两个长度为1的子序列合并为一个长度为2的有序序列。
4. 重复步骤3，将长度为2的有序序列合并为长度为4的有序序列，以此类推，直到整个序列有序。

```CPP
/// @brief 归并排序合并函数
/// @param nums 
/// @param p 
/// @param q 
/// @param r 
void Merge(vector<int> &nums, int p, int q, int r)
{
    int length = r - p + 1;
    // 申请临时数组
    int *temp = new int[length];
    // 比较左右序列，按序放入临时数组
    int i = p, j = q + 1, k = 0;
    while (i <= q && j <= r)
        temp[k++] = nums[i] <= nums[j] ? nums[i++] : nums[j++];
    // 处理剩余元素
    int start = i <= q ? i : j, end = i <= q ? q : r;
    while (start <= end)
        temp[k++] = nums[start++];
    // 将临时数组复制回原数组
    for (int x = p; x <= r; x++)
        nums[x] = temp[x - p];
    delete[] temp;
}

/// @brief 归并排序递归函数
/// @param nums 
/// @param p 
/// @param r 
void MergeSortR(vector<int> &nums, int p, int r)
{
    if (p >= r)
        return;
    // 划分左右序列，分别进行排序
    int q = (p + r) / 2;
    MergeSortR(nums, p, q);
    MergeSortR(nums, q + 1, r);
    // 合并序列
    Merge(nums, p, q, r);
}

void MergeSort(vector<int> &nums)
{
    MergeSortR(nums, 0, nums.size() - 1);
}
```

#### 计数排序

计数排序是一种高效的线性时间排序算法，它的基本思想是通过统计待排序元素值出现的次数，然后根据这些次数将元素放到正确的位置上。

计数排序的具体步骤如下：

1. 遍历待排序数组A，统计每个元素值出现的次数，存储在数组C中。
2. 对数组C进行排序，使得C[i]表示的次数小于C[i+1]表示的次数，这里i从0到C长度减1。
3. 遍历数组A，根据数组C，将元素放到正确的位置上。

计数排序的时间复杂度为O(n+k)，其中n是待排序数组的长度，k是待排序数据的值域大小。由于计数排序不需要进行比较，因此它的效率非常高。

```CPP
class CountingSort {  
public:  
    static void sort(std::vector<int> &nums) {  
        int minValue = nums[0], maxValue = nums[0];  
        // 找到数组中的最大和最小值，确定计数数组的长度  
        for (int &num: nums) {  
            minValue = num < minValue ? num : minValue;  
            maxValue = num > maxValue ? num : maxValue;  
        }  
        std::vector<int> count(maxValue - minValue + 1, 0);  
        // 统计每一个数据出现的次数  
        for (int &num: nums) count[num - minValue]++;  
        // 按序将数据放回原数组  
        for (int i = 0, k = 0; i < count.size(); i++)  
            while (count[i]-- > 0) nums[k++] = i + minValue;  
    }  
};
```

# 回溯算法

#### 子集

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。

解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。
ll
```CPP
class Solution {
public:
    void helper(vector<int> &nums, int index, vector<int> &subsets, vector<vector<int>> &result) {
        if(index >= nums.size()) {
            result.push_back(subsets);
        } else {
            helper(nums, index + 1, subsets, result);
            
            subsets.push_back(nums[index]);
            helper(nums, index + 1, subsets, result);
            subsets.pop_back();
        }
    }
    
    vector<vector<int>> subsets(vector<int> &nums) {
        vector<vector<int>> result;
        vector<int> subsets;
        helper(nums, 0, subsets, result);
        return result;
    }
};
```

#### 组合

给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。

你可以按 **任何顺序** 返回答案。

```CPP
class Solution {
public:
    void helper(int n, int k, int i, vector<int> &combination, vector<vector<int>> &result) {
        if (combination.size() == k) {
            result.push_back(combination);
        } else if (i <= n) {
            helper(n, k, i + 1, combination, result);
            
            combination.push_back(i);
            helper(n, k, i + 1, combination, result);
            combination.pop_back();
        }
    }
    
    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> result;
        vector<int> combination;
        helper(n, k, 1, combination, result);
        return result;
    }
};
```

**迭代+剪枝优化：**

```CPP
class Solution {
public:
    void backTracking(int n, int k, int start, vector<int> &combination, vector<vector<int>> &result) {
        if (combination.size() == k) {
            result.push_back(combination);
            return;
        }
        for(int i = start; i <= n - (k - combination.size()) + 1; ++i) {
            combination.push_back(i);
            backTracking(n, k, i + 1, combination, result);
            combination.pop_back();
        }
    }

    vector<vector<int>> combine(int n, int k) {
        vector<vector<int>> result;
        vector<int> combination;
        backTracking(n, k, 1, combination, result);
        return result;
    }
};
```

#### 组合总和

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

```CPP
class Solution {  
public:  
    void helper(vector<int> &nums, int target, int i, vector<int> &combination, vector<vector<int>> &result) 
    {  
        if (target == 0) {  
            result.emplace_back(combination);  
        } else if (target > 0 && i < nums.size()) {  
            helper(nums, target, i + 1, combination, result);  
            
            combination.push_back(nums[i]);  
            helper(nums, target - nums[i], i, combination, result);  
            combination.pop_back();  
        }  
    }  
    
	vector<vector<int>> combinationSum(vector<int> &candidates, int target)
	{  
        vector<vector<int>> result;  
        vector<int> combination;  
        helper(candidates, target, 0, combination, result);  
        return result;  
    }  
};
```

#### 组合总和Ⅱ

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：**解集不能包含重复的组合。

```CPP
class Solution {
public:
    int getNext(vector<int> &nums, int index) {
        int next = index;
        while (next < nums.size() && nums[index] == nums[next]) next++;
        return next;
    }
    
    void helper(vector<int> &candidates, int target, int i, vector<int> &combination, vector<vector<int>> &result) {
        if (target == 0) {
            result.push_back(combination);
        } else if (target > 0 && i < candidates.size()) {
            helper(candidates, target, getNext(candidates, i), combination, result);
            
            combination.push_back(candidates[i]);
            helper(candidates, target - candidates[i], i + 1, combination, result);
            combination.pop_back();
        }
    }
    
    vector<vector<int>> combinationSum2(vector<int> &candidates, int target) {
        sort(candidates.begin(), candidates.end());
        
        vector<vector<int>> result;
        vector<int> combination;
        helper(candidates, target, 0, combination, result);
        
        return result;
    }
};
```

#### 组合总和Ⅲ

找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：

- 只使用数字1到9
- 每个数字 **最多使用一次** 

返回 _所有可能的有效组合的列表_ 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

```CPP
class Solution {
public:
    vector<vector<int>> combinationSum3(int k, int n) {
        vector<vector<int>> result;
        vector<int> combination;
        backTracking(k, n, 1, combination, result);
        return result;
    }

private:
    void backTracking(int k, int n, int startIndex, vector<int> &combination, vector<vector<int>> &result) {
        if(n < 0) return;
        if(combination.size() == k) {
            if(n == 0) {
                result.push_back(combination);
            }
            return;
        }
        for(int i = startIndex; i <= 9 - (k - combination.size()) + 1; ++i)
        {
            n -= i;
            combination.push_back(i);
            backTracking(k, n, i + 1, combination, result);
            combination.pop_back();
            n += i;
        }
    }
};
```

#### 电话号码的字母组合

给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。

给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。

![](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/11/09/200px-telephone-keypad2svg.png)

```CPP
class Solution {
public:
    vector<string> letterCombinations(string digits) {
        if(digits.size() == 0) return {};
        numToAlphas = {"abc", "def", "ghi", "jkl","mno", "pqrs", "tuv", "wxyz"};
        vector<string> result;
        string combination;
        backTracking(digits, 0, combination, result);
        return result;
    }
    
private:
    vector<string> numToAlphas;
    
    void backTracking(string digits, int index, string &combination, vector<string> &result) {
        if(combination.size() == digits.size()) {
            result.push_back(combination);
            return;
        }
        int digit = digits[index] - '0' - 2;
        for(int i = 0; i < numToAlphas[digit].size(); ++i) {
            combination.push_back(numToAlphas[digit][i]);
            backTracking(digits, index + 1, combination, result);
            combination.pop_back();
        }
    }
};
```

#### 全排列

给定一个不含重复数字的数组 `nums` ，返回其 _所有可能的全排列_ 。你可以 **按任意顺序** 返回答案。

```CPP
class Solution {
public:
    void helper(vector<int> &nums, int i, vector<vector<int>> &result) {
        if (i == nums.size()) {
            vector<int> permutation;
            for (int &num: nums) {
                permutation.push_back(num);
            }
            result.push_back(permutation);
        } else {
            for (int j = i; j < nums.size(); ++j) {
                swap(nums[i], nums[j]);
                helper(nums, i + 1, result);
                swap(nums[i], nums[j]);
            }
        }
    }
    
    vector<vector<int>> permute(vector<int> &nums) {
        vector<vector<int>> result;
        helper(nums, 0, result);
        return result;
    }
};
```

#### 全排列Ⅱ

给定一个可包含重复数字的序列 `nums` ，_**按任意顺序**_ 返回所有不重复的全排列。

```CPP
class Solution {
public:
    void helper(vector<int> &nums, int i, vector<vector<int>> &result) {
        if (i == nums.size()) {
            vector<int> permutation;
            for (int &num: nums) permutation.push_back(num);
            result.push_back(permutation);
        } else {
            unordered_set<int> set;
            for (int j = i; j < nums.size(); ++j) {
                if (set.find(nums[j]) != set.end()) continue;
                set.emplace(nums[j]);
                swap(nums[i], nums[j]);
                helper(nums, i + 1, result);
                swap(nums[i], nums[j]);
            }
        }
    }
    
    vector<vector<int>> permuteUnique(vector<int> &nums) {
        vector<vector<int>> result;
        helper(nums, 0, result);
        return result;
    }
};
```
# 贪心算法

#### 分发饼干

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。

对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

```CPP
class Solution {
public:
    int findContentChildren(vector<int>& g, vector<int>& s) {
        sort(g.begin(), g.end());
        sort(s.begin(), s.end());
        
        int index = s.size() - 1;
        int count = 0;
        
        for(int i = g.size() - 1; i >= 0 && index >= 0; --i) {
            if(s[index] >= g[i]) {
                ++count;
                --index;
            }
        }
        
        return count;
    }
};
```

#### 摆动序列

如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。

- 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
    
- 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。

**子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。

给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。

```CPP
class Solution {
public:
    int wiggleMaxLength(vector<int> &nums) {
        int n = nums.size();
        if (n <= 1) return n;
        int preDiff = nums[1] - nums[0];
        int count = preDiff == 0 ? 1 : 2;
        for (int i = 1; i < n; ++i) {
            int diff = nums[i] - nums[i - 1];
            if (diff * preDiff < 0 || preDiff == 0 && diff != 0) {
                ++count;
                preDiff = diff;
            }
        }
        return count;
    }
};
```

# 动态规划

#### 使用最小花费爬楼梯

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

```CPP
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int length = cost.size();
        vector<int> dp(length, 0);
        dp[0] = cost[0];
        dp[1] = cost[1];
        for(int i = 2; i < length; i++) {
            dp[i] = min(dp[i-2], dp[i-1]) + cost[i];
        }
        return min(dp[length-2], dp[length-1]);
    }
};
```

**优化空间复杂度：**

```CPP
class Solution {
public:
    int minCostClimbingStairs(vector<int>& cost) {
        int length = cost.size();
        vector<int> dp { cost[0], cost[1] };
        for(int i = 2; i < length; i++) {
            dp[i%2] = min(dp[0], dp[1]) + cost[i];
        }
        return min(dp[0], dp[1]);
    }
};
```

#### 不同路径

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

```CPP
class Solution {
public:
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 1));
        for(int i = 1; i < m; i++) {
            for(int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
};
```

#### 不同路径 Ⅱ

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

网格中的障碍物和空位置分别用 `1` 和 `0` 来表示。

```CPP
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
        int rows = obstacleGrid.size();
        int columns = obstacleGrid[0].size();
        // 起点或终点是障碍的情况
        if(obstacleGrid[0][0] || obstacleGrid[rows-1][columns-1]) return 0;
        vector<vector<int>> dp(rows, vector<int>(columns, 0));
        // 初始化dp数组
        dp[0][0] = 1;
        for(int i = 1; i < rows && obstacleGrid[i][0] != 1; i++) dp[i][0] = 1; 
        for(int j = 1; j < columns && obstacleGrid[0][j] != 1; j++) dp[0][j] = 1;
         
        for(int i = 1; i < rows; i++) {
            for(int j = 1; j < columns; j++) {
                if(obstacleGrid[i][j]) continue;
                else dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[rows-1][columns-1];
    }
};
```

#### 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

```CPP
class Solution {
public:
    int rob(vector<int>& nums) {
        vector<int> dp(nums.size(), 0);
        dp[0] = nums[0];
        if(nums.size() > 1)
            dp[1] = max(nums[0], nums[1]);
        for(int i = 2; i < nums.size(); i++) {
            dp[i] = max(dp[i-1], dp[i-2] + nums[i]);
        }
        return dp[nums.size() - 1];
    }
};
```

**优化空间复杂度：**

```CPP
class Solution {
public:
    int rob(vector<int>& nums) {
        vector<int> dp(2, 0);
        dp[0] = nums[0];
        if(nums.size() > 1)
            dp[1] = max(nums[0], nums[1]);
        for(int i = 2; i < nums.size(); i++) {
            dp[i%2] = max(dp[(i-1)%2], dp[(i-2)%2] + nums[i]);
        }
        return max(dp[0], dp[1]);
    }
};
```

#### 打家劫舍 Ⅱ

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

```CPP
class Solution {
public:
    int rob(vector<int>& nums) {
        if(nums.size() == 1) return nums[0];
        int result1 = helper(nums, 0, nums.size() - 2);
        int result2 = helper(nums, 1, nums.size() - 1);
        return max(result1, result2);
    }
    
    int helper(vector<int>& nums, int start, int end) {
        vector<int> dp(2, 0);
        dp[0] = nums[start];
        if(start < end)
            dp[1] = max(nums[start], nums[start+1]);
        for(int j = start + 2; j <= end; j++) {
            int i = j - start;
            dp[i%2] = max(dp[(i-1)%2], dp[(i-2)%2] + nums[i]);
        }
        return dp[(end-start)%2];
    }
};
```

#### 粉刷房屋

假如有一排房子，共 `n` 个，每个房子可以被粉刷成红色、蓝色或者绿色这三种颜色中的一种，你需要粉刷所有的房子并且使其相邻的两个房子颜色不能相同。

当然，因为市场上不同颜色油漆的价格不同，所以房子粉刷成不同颜色的花费成本也是不同的。每个房子粉刷成不同颜色的花费是以一个 `n x 3` 的正整数矩阵 `costs` 来表示的。

例如，`costs[0][0]` 表示第 0 号房子粉刷成红色的成本花费；`costs[1][2]` 表示第 1 号房子粉刷成绿色的花费，以此类推。

请计算出粉刷完所有房子最少的花费成本。

```CPP
class Solution {
public:
    int minCost(vector<vector<int>>& costs) {
        for(int i = 1; i < costs.size(); i++) {
            costs[i][0] += min(costs[i-1][1], costs[i-1][2]);
            costs[i][1] += min(costs[i-1][0], costs[i-1][2]);
            costs[i][2] += min(costs[i-1][0], costs[i-1][1]);
        }
        int last = costs.size() - 1;
        return min(min(costs[last][0], costs[last][1]), costs[last][2]);
    }
};
```

#### 整数拆分

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 _你可以获得的最大乘积_ 。

```CPP
class Solution {
public:
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[0] = 0;
        dp[1] = 1;
        for(int i = 2; i <= n; ++i) {
            int currentMax = 0;
            for(int j = 1; j < i; ++j) {
                currentMax = max(currentMax, max(j * (i - j), j * dp[i - j]));
            }
            dp[i] = currentMax;
        }
        return dp[n];
    }
};
```

#### 不同的二叉搜索树

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

```CPP
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        dp[1] = 1;
        for(int i = 2; i <= n; ++i) {
            for(int j = 1; j <= i; ++j) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```