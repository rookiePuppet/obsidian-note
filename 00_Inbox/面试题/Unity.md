#### MonoBehaviour生命周期函数

- **Awake。** 第一次加载时调用，用于执行一些只需执行一次的初始化操作。
- **OnEnable。** 游戏对象被启用时调用。
- **Start。** 游戏对象第一次成为激活状态时调用，通常用于执行一些游戏开始时只需执行一次的操作。
- **Fixed Update。** 在每一次固定的更新周期中调用，通常用于物理计算和其他需要固定时间步长的操作，如AI决策、动画混合等。
- **Update。** 每一帧调用，通常用于处理每一帧需要执行的操作，如更新位置、检查碰撞等。
- **Late Update。** 在每一帧渲染完成后调用，通常用于处理摄像机跟随或其他需要在Update函数之后执行的逻辑。
- **OnDisable。** 游戏对象被禁用时调用。
- **OnDestroy。** 游戏对象被销毁时调用。用于清理资源，如删除对其他对象的引用等。

> 为什么摄像机跟随的代码要写在LateUpdate函数中？

因为LateUpdate函数在Update之后执行，而摄像机跟随也需要在游戏物体移动完成后执行，这样可以确保摄像机始终能跟随游戏物体，避免出现卡顿的情况。

> 物理更新放在哪个函数中？

FixedUpdate。因为FixedUpdate是固定一个时间间隔调用一次，不受游戏帧率影响，而物理计算需要精确和固定的时间来保证正确结果，避免帧率时高时低对物理模拟结果的影响。

#### 协程

Unity的协程是基于C#的迭代器实现的。

协程函数是一个返回值为IEnumerator的函数，当遇到yield return语句时，Unity会保存当前函数的执行状态，将协程挂起，等待条件满足后才恢复执行。

Unity在主线程上维护一个协程队列，用来管理和调度所有的协程。每帧都会对每一个协程进行检查，查看是否满足恢复条件，如果满足就调用MoveNext()函数。

调用协程函数时，底层会包装一个状态机类，用于保存协程的状态。调用MoveNext()时，根据当前状态跳转到相应代码位置执行。

#### 碰撞器和触发器的区别

- **碰撞器：** 碰撞器用于处理物体之间的物理碰撞。当碰撞器组件Is Trigger属性为false时，碰撞器会根据物理引擎产生碰撞效果，通过OnCollisionEnter/Stay/Exit函数来处理碰撞事件。
- **触发器：** 触发器是碰撞器的一个属性，用于检测物体是否经过某个区域。当碰撞器组件Is Trigger属性为true时，碰撞器被物理引擎所忽略，不会产生碰撞效果，通过OnTriggerEnter/Stay/Exit函数来处理触发事件。

#### 物体发生碰撞的必要条件

两个物体必须带有碰撞器，其中一个物体必须有刚体。

#### Unity提供的光源有哪些

- 平行光，Directional Light
- 点光源，Point Light
- 聚光灯，Spot  Light
- 区域光源，Area Light

#### 四元数的作用，相对欧拉角的优点

四元数用于表示物体的旋转，计算旋转角度时使用四元数。

相对欧拉角的优点：

1. 能进行增量旋转。
2. 避免了万向节死锁。
3. 给定旋转的表示方式只有两种，互为负。

#### CharacterController和Rigidbody的区别

Rigidbody具有完全真实的物理特性，可以模拟真实的物理效果，包括重力以及其他各种外力的影响。

CharacterController是为了方便开发第一人称视角游戏而产生的，具备一定的物理效果，但不完全真实，只会受到重力影响。

总的来说，Rigidbody更适合用来模拟真实世界中的物体，如车辆等。而CharacterController则更适合用来控制游戏中的角色，如第一人称或第三人称视角中的角色。

#### localPosition和Position在使用上的区别

localPosition是相对本地/自身坐标系的，也就是相对父物体的位置。

Position是相对世界坐标系的，就是物体在世界中的位置。

#### Prefab预制体

Prefab在Unity中是一种非常重要的资源类型，主要有以下几个用途：

1. 复用：可以将一组游戏对象制作成Prefab，在场景中各个位置和多个场景中重复使用。
2. 统一管理：对Prefab做的修改都会反映到所有该Prefab的实例中，这样就可以轻松对场景物体进行更改，不用对每个副本进行重复的编辑修改操作。
3. 动态加载：可以在需要使用到某个游戏对象时通过加载Prefab的方式，在特定时机实例化游戏对象。
4. 节省内存：频繁创建物体时，使用Prefab可以节省内存。

> 预制体的本质

**Unity预制体的本质是一种资源文件，它允许创建、配置和存储游戏对象及其所有组件、属性值和子游戏对象作为可重用资源**。简单来说，预制体就是用来存储一个游戏对象的所有组件，属性和子对象，这样就成为了一个可重复使用的资源文件。当需要多次重复使用这个游戏对象时，便可以使用预制体来创建。这种机制使得开发者能够更高效地创建和管理游戏对象，同时确保这些对象在游戏中的一致性。

#### 进程、线程、协程的概念

> 进程

- 保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，不同进程间可以进行进程间通信，上级挂靠单位是操作系统。
- 一个应用程序相当于一个进程，操作系统会以进程为单位，分配系统资源（CPU 时间片、内存等资源），进程是操作系统资源分配的最小单位。

> 线程

- 线程从属于进程，也被称为轻量级进程，是程序的实际执行者。线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。一个线程只有一个进程。
- 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口，但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
- 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。

> 协程

- 协程是伴随着主线程一起运行的一段程序。
- 协程与协程之间是并行执行，与主线程也是并行执行，同一时间只能执行一个协程。提起协程，自然是要想到线程，因为协程的定义就是伴随主线程来运行的。
- 一个线程可以拥有多个协程，协程不是被操作系统内核所管理，而完全是由程序所控制。
- 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。
- 协程是单线程下由应用程序级别实现的并发。

#### 简述协程的作用

协程可以在不创建新线程的情况下实现异步等待和延迟执行，避免了线程切换和同步等开销，能够提高程序的性能和效率。

一般可以用来完成异步加载资源等等耗时的操作，避免游戏卡顿。

需要注意，协程不是多线程。因为协程是在主线程中执行的，所以协程中的操作不能阻塞主线程。

#### 简述Unity协程的底层原理

Unity中的协程是通过迭代器实现的。

迭代器是一种特殊的函数，它可以在执行过程中暂停，并在需要时恢复执行。

Unity协程主要分两部分：协程函数和协程调度器。协程函数就是一个能够中间暂停返回的函数，而协程调度是在MonoBehaviour的生命周期中实现的，Unity只实现了协程调度部分，协程函数本身其实就是用了C#原生的迭代器方法。

#### 简述Invoke和InvokeRepeating

Invoke方法是Unity的一种委托机制，可以延迟执行某个函数。Invoke必须在脚本生命周期函数中调用，不能接收带有参数的方法，当Time.timeScale为0时，Invoke无效。

InvokeRepeating方法可以延迟并指定时间间隔重复执行某个函数。

#### 正在运行的脚本，隐藏物体与禁用脚本导致触发OnDisable时，Invoke和Coroutine是否正常运行

只禁用脚本，Invoke和Coroutine都会正常运行。

把物体隐藏，协程会停止，Invoke正常运行。

> 物体或组件被销毁，Invoke不执行。物体或组件失活，Invoke正常执行。
> 物体或组件被销毁，Coroutine不执行。物体失活，Coroutine不执行；组件失活，Coroutine正常执行。

#### 物体发生碰撞的三个阶段

OnCollisionEnter、OnCollisionStay、OnCollisionExit。

#### 刚体施加力的方式

- `Rigidbody.AddForce`
- `Rigidbody.AddForceAtPosition`

#### 物体自身旋转和绕某个点旋转的函数

自身旋转：Transform.Rotate

绕某个点旋转：Transform.RotateAround

#### Unity提供了用于存取数据的类，列出存取数据的函数

PlayerPrefs类是一个本地持久化保存与读取数据的类，支持3种数据类型，浮点型、整型和字符串型。

- SetInt - GetInt
- SetFloat - GetFloat
- SetString - GetString

#### Image和RawImage的区别

Image组件：

- 用于交互。
- 支持Sprite类型的图片。
- 可以对图片进行缩放、旋转、填充等操作。
- 可以设置图片的颜色、透明度等属性。

RawImage组件：

- 用于显示非交互的图像控件，一般用在背景、图标上。
- 支持任何类型的图片。
- 支持UV Rect（用来设置只显示图片的某一部分）。
- 只能设置颜色属性。

#### 在场景中放置多个Camera并同时处于活动状态会发生什么

游戏界面上会显示多个摄像机渲染后混合的画面，混合的效果取决于每个摄像机的深度depth属性，深度大的摄像机会覆盖深度小的摄像机。此外，还可以通过Culling Mask属性来控制摄像机能看到场景中的哪些对象，如果不希望某个摄像机显示内容，可以将其enable属性设置为false。

#### 如何销毁一个UnityEngine.Object及其子类

使用`Object.Destroy`方法。

#### 描述游戏动画有哪几种及其原理

1. 赛璐璐动画（Cel Animation）：2D动画的前身，每一张静止的图片称为一帧，连续快速地显示多帧的静止图片就产生了动画（视觉暂留效应）。在游戏引擎中的实现为精灵动画，在一张背景图上，利用不同的序列帧合成播放出来的2D动画。
2. 刚性层阶式动画（Rigid Hierarchical Animation）：在建模的时候把人物拆成不同的部位，制作动画时用代码逻辑去控制移动的部位（像低阶骨骼动画的初版）。
3. 顶点动画（Pre-Vertex-Animation）：以顶点为最小单位制作的动画，可以制作非常高精度的动画（动捕也是基于顶点的动画），此类动画也有一个分支——变形目标动画（Morph Target Animation），也是现在游戏中常用的动画技术，制作部分固定的动画姿势，在运行时利用线性插值对这些姿势进行混合生成动画。
4. 蒙皮动画（Skinned Animation）：这种动画需要将3D模型的顶点与骨骼结构相关联，当移动骨骼时，与其相关的模型顶点也会随之移动，使得动画看起来更加自然和逼真。
5. 程序动画：这种动画基本上不是靠动画师制作，是程序在shader或者代码里面进行制作，一般用于比如树或草的动画，UI动画或者UV动画等。

#### 请描述为什么会发生在组件上出现数据丢失的情况

可能是因为组件上绑定的物体对象被删除了，或移动到了其他位置。

#### LOD的概念及其缺点

LOD（Level of Detail）多层次细节，是一种游戏优化技术。

按照模型的位置和重要程度决定物体渲染的资源分配，降低非重要物体的面数和细节度，从而获得高效率的渲染运算。

也就是说根据摄像机与模型的距离，来决定显示哪一种模型，一般距离近的时候显示高精度多细节的模型，距离远的时候显示低精度少细节的模型，来加快整体场景的渲染速度。

缺点是同一模型要准备多个精度不同的模型，增加了内存消耗。

#### MipMap是什么，有什么用

在电脑上显示图像时，图像数据需要被解析成像素并以二维的方式显示在屏幕上，而MipMap技术是一种特殊的二维图像数据，通过算法预先计算出图像在各个观察者位置的像素变化情况，从而在渲染图像时提高画面的立体感。

MipMap按照距离观察者的远近分为多个层级，每个层级包含逐渐减少的像素数目。当观察者距离图像越远时，显示包含较少像素的层级，当距离近时，显示包含更多像素的层级。

这种技术可以减少图像渲染时的计算量，提高渲染效率，同时也可以增强图像的立体感。

#### 在Unity中，有时在第一次执行GameObject.Instantiate的时候有明显卡顿，该怎么解决

- **加载过大资源造成卡顿**
	- 预加载资源。
	- 简化资源（修改图片大小，减少模型顶点、面数、压缩优化资源等）。
	- 异步加载资源（分帧加载）。
- **对象挂载的脚本中初始化耗时**
	- 减少序列化或反序列信息。
	- 优化初始化相关逻辑，提前初始化，分帧初始化等。

#### 在Unity中AssetBundle的压缩方式有不压缩、LZMA、LZ4三种，请问LZMA和LZ4有什么区别

- LZMA压缩包最小，但是解压过程慢，耗时长。
- LZ4压缩包较大，但是不用解压全部数据，耗时短。

#### Unity中DrawCall、Batches、SetPass Calls的区别

- **DrawCall**表示渲染请求的数量（每个DrawCall都会引起一次从CPU到GPU的数据传输），直接影响渲染性能，因为它决定CPU和GPU之间的通信次数。减少DrawCall的数量通常是优化渲染性能的关键之一，可以通过批处理技术来合并DrawCall。
- **Batches**是一种将多个物体合并为一个DrawCall的渲染优化技术，它将多个相似的物体合并成一个DrawCall从而减少CPU到GPU的数据传输和渲染开销，可以使用静态批处理、动态批处理和GPU Instancing等技术来进一步优化。
- **SetPass Calls**是渲染Pass（Shader中渲染通道）的数量，移动平台中尽量减少Shader中Pass的数量可以提升性能。

#### Unity Shader中，深度测试是在做什么

深度测试用于确定哪些像素应该被绘制到屏幕上，并确定它们的可见性。
主要目标是解决遮挡关系，确保前面的对象覆盖后面的对象，从而正确呈现场景。

#### Unity Shader中，某片元通过了深度测试，但是没有开启深度写入，该片元的颜色信息是否写入到颜色缓冲区

会写入颜色缓冲区。因为深度写入和颜色写入是两个独立的操作，只要通过了深度测试，不管是否写入深度缓冲区，该片元的颜色信息都会写入到颜色缓冲区。

#### 对象池

对象池是一种常用的优化策略和设计模式，可以大量减少内存碎片和频繁的内存分配和销毁。当需要使用对象时，先查看对象池中是否有闲置的对象，如果有则直接取出使用，没有则新创建对象。当不需要使用对象时，不会将对象销毁，而是将对象放入对象池以便后续使用。

> 什么时候需要用对象池

在游戏中需要频繁创建/实例化对象的地方，都可以用到对象池。

比如前端开发中，游戏中的子弹、伤害字体、特效等等，后端开发中线程池等等。

#### Unity是否支持多线程程序，需要注意什么

Unity支持写多线程的程序，但是只能在主线程中使用Unity引擎相关的资源、API等，子线程中访问引擎相关资源会出错。

另外，Unity也为我们提供了协程以及一些加载资源、场景的异步方法。

#### 如何让已经存在的GameObject在切换场景后不被删除

使用`DontDestroyOnLoad`方法。

例如`DontDestroyOnLoad(gameObject)。

#### 向量的点乘、叉乘以及归一化的意义

点乘（内积）：描述了两个向量的相似程度，点乘结果是一个标量，值越大表示两向量越相似，还可表示投影。可用于计算两个向量的夹角，判断物体的方位。

叉乘（外积）：叉乘结果是一个向量，垂直于原来的两个向量，也是这两个向量所在平面的法向量。可用于判断一个物体在另一个物体的左侧还是右侧。

归一化：一个非零向量除以其模长，变成一个长度为1的向量，即单位向量。

#### 当一个细小高速的物体撞向一个较大物体时，会发什么情况

可能会出现穿透（碰撞检测失败）的情况。

可通过使用合适的碰撞体，限制最大速度，使用连续碰撞检测等方法来避免，也可以使用射线检测代替。

#### 简述如何在不同分辨率下保持UI的一致性

- 使用锚点：锚点可以将UI元素固定在父级容器的某个位置，使UI元素在不同分辨率下自适应缩放，从而保持UI的一致性。
- 使用Canvas Scaler组件：使用Canvas Scaler动态地调整Canvas的大小和锚点，以适应屏幕分辨率。将UI Scale Mode设置为Scale With Screen Size，并设置当前开发参考的分辨率，以及Match Width or Height属性调整适配方式。

#### 动态合批与静态合批

动态合批（批处理）和静态合批（批处理）都是游戏引擎中的优化技术，用于减少CPU对GPU绘制请求的次数，以提高渲染效率。

静态合批是将静态物体合并成大网格，从而更快地渲染它们。

动态合批是在运行时Unity自动把画面中使用相同材质的多个模型网格合并，提高渲染效率。

#### 动态加载资源的方式

- **使用Resources.Load()方法**：Resources.Load()方法可以从Resources文件夹中加载资源。这种方式适用于需要在运行时动态加载的资源，如场景、材质、纹理等。
- **使用AssetBundle.LoadFromFile()方法**：AssetBundle是一种打包资源的方式，可以将多个资源打包成一个文件。AssetBundle.LoadFromFile()方法可以从AssetBundle文件中加载资源。这种方式适用于需要在运行时动态加载的大型资源，如场景、模型等。
- **使用WWW类**：WWW类可以从网络或本地文件系统中加载资源。这种方式适用于需要从远程服务器或本地磁盘中动态加载资源的情况。

#### 什么是Light Map

Light Map是指在三维软件中，通过模拟灯光并将灯光对物体产生的影响，即明暗信息保存在一张贴图上，然后将这张贴图应用到场景中的过程。其目的是为了使物体在渲染后具有光照效果。

#### Unity Shader有几种，区别是什么

1. **Fixed function shader**：这是属于固定渲染管线Shader，基本用于高级Shader在老显卡无法显示时的Fallback。使用的是ShaderLab语言，语法与微软的FX files或者NVIDIA的CgFX类似。
2. **Vertex and Fragment Shader**：这是最强大的Shader类型，属于可编程渲染管线，使用的是CG/HLSL语法。
3. **Surface Shader**：这是Unity3D推崇的Shader类型，使用Unity预制的光照模型来进行光照运算，使用的也是CG/HLSL语法。

#### Unity中摄像机的Clipping Planes作用是什么？调整Near、Far两个值时要注意什么

摄像机的Clipping Planes（剪裁平面）用于定义从相机开始渲染到停止渲染之间的距离，这主要影响场景中被渲染的内容。

Near值定义了相机前部的裁剪平面，即物体距离相机多近时会被渲染。

Far值定义了相机后部的裁剪平面，即物体距离相机多远时会被渲染。

在调整两个值时需要注意：

1. 场景的深度范围：如果场景中的对象距离摄像机太近或太远，都可能会导致对象被裁剪掉，即在渲染结果中看不到这些对象。
2. 性能考虑：如果裁剪平面设置得太远或太近，可能会导致渲染的次数增多或减少，影响游戏性能。
3. 相机的移动：如果相机在场景中移动，要注意裁剪平面是否会随着摄像机的移动而移动，因为这可能导致场景中的对象在相机移动时出现或消失，影响视觉效果。

#### 将摄像机的ClearFlags设置成Depth only有什么用

将ClearFlags设置成Depth only意味着摄像机只会关注深度信息，而忽略颜色信息。

这种模式在处理复杂的摄像机动画或多个摄像机同时工作的场景时特别有用，可以让摄像机只渲染其视角内的对象。

需要注意的是，这种模式在性能上有一定的开销。

#### 在编辑场景时将GameObject设置为Static有何作用

当一个游戏对象为Static时，这个对象会被渲染引擎认为是静态的，并且在游戏过程中不会移动或改变，可以用于多种情况：

1. 当场景中某个物体不会在游戏过程中移动时，将其设置为Static可以使其成为一个参考点或背景，从而提高游戏的稳定性的性能。
2. 在游戏制作过程中，有时需要使用碰撞检测来触发某些事件或者决定物体的行为，将不会移动的物体设置为Static可以使碰撞检测更加准确和高效。
3. 在一些需要精确控制视角或预测游戏对象行为的场景中，将物体设置为Static可以使其成为一个固定的参考点，从而更加方便控制视角或预测物体的行为。

需要注意的是，在游戏运行时，Static物体不会被渲染引擎自动剔除或者隐藏，也就是说，如果场景中存在大量的Static物体，可能会对游戏的性能产生影响。因此，应该谨慎使用Static属性，只在必要的情况下使用。

#### 什么是DrawCall？对游戏的影响？如何降低

**DrawCall**是CPU准备好数据通知GPU进行渲染的一个指令。

对于游戏来说，DrawCall过多可能会**导致帧率降低**。因为CPU每次调用DrawCall，都需要向GPU发送许多数据和状态， 在发送前CPU需要从硬盘读取到显存的数据、设置的渲染状态以及调用DrawCall命令操作。一旦CPU执行完应用阶段，CPU则开始执行渲染。*由于GPU渲染的速度比CPU提交命令的速度快得多，所以性能就会被CPU的提交速度所影响*。如果DrawCall数量过多，CPU就会在提交命令上花费大量时间，导致帧率下降。

**降低DrawCall的方法：**

1. 批处理：把众多小的DrawCall合并成一个DrawCall。这种方法比较适合静态的网格，不是所有情况都能合并，而且要注意避免使用大量小的网格和过多的材质。
2. 优化渲染路径：通过优化渲染路径，可以尽量减少CPU和GPU之间的数据传输量，提高渲染效率。
3. 使用更高效的算法：采用更高效的算法来处理渲染数据，例如采用空间划分技术或者缓存技术，以提高渲染效率。

#### 什么是顶点着色器和片元着色器

**顶点着色器**：用于描述顶点特性的程序，例如位置、颜色等。每个顶点都会执行一次顶点着色器，但着色器程序运行过程中无法访问其他顶点的数据。

**片元着色器**：用于计算和填充图形中每个像素点的颜色。这个过程通常是并行的，每个像素都会执行一次片元着色器。

#### 不同文件夹的性质

1. **Resources**：可读不可写，打包后找不到。
2. **Application.streamingAssetsPath**：可读，PC端可写，找得到。
3. **Application.dataPath**：打包后找不到。
4. **Application.persistentDataPath**：可读可写找得到。