
## 游戏数据存储与读取

游戏数据和配置文件采用**JSON**格式，使用自制**JSON数据管理器**。

通过Excel做游戏数据的配置，在网页上使用**Excel转JSON**的工具转换成JSON格式，然后复制到**Streaming Assets**文件夹下的JSON文件中。

另外写了游戏数据管理器，用于读取游戏配置信息和游戏数据，以及音乐音效的设置数据，提供保存玩家游戏数据和音效设置的数据。

![[Pasted image 20231028092049.png]]

![[Pasted image 20231028092236.png]]

## 游戏UI

使用**UGUI**制作，在逻辑层面是先实现一个抽象基类**BasePanel**，提供显隐面板和初始化的接口，所有游戏面板都继承BasePanel，并被UIManager所管理。

**UIManager**是一个单例类，持有一个存储所有面板的字典，键是string，值是BasePanel。主要提供显示、隐藏以及获得某个面板的接口，通过函数泛型指定面板（利用反射获得泛型的名称，在Resources目录中加载对应的面板预设体，需要保证预设体名称和对应面板脚本名称相同）。

## 防御塔

### 防御塔对象

攻击方式有单体攻击和群体攻击，都是使用Physics.OverlapSphere范围检测来获取附近的怪物对象，攻击范围、伤害、cd等属性可通过配置文件修改。

攻击逻辑在Update函数中，首先寻找攻击的目标，然后将炮口旋转至对象，按cd间隔进行开火，开火时实例化开火的特效、音效，再让目标受到伤害。

### 造塔点

利用触发器，当玩家进入造塔点范围时显示造塔选项，一开始统一显示三种基础塔选项，造完塔之后将塔对象保存在自己身上，下次玩家进入时发现这个位置已经造过塔了，就显示当前塔的下一级选项，选择进行升级。

## 怪物

### 怪物对象

有四种不同的怪物，通过配置文件来配置各种怪物的属性，包括移动速度、攻击力、血量等。

动画状态机制作上，首先制作一种怪物的状态机，其余几种复用同一个状态机，然后修改动画切片即可。

怪物脚本的Update函数中，使用Physics.OverlapSphere函数检测玩家和防御塔，有玩家优先以玩家为目标，发现目标以后朝目标移动，到目标面前停止移动再攻击。如果Overlap函数没有检测到防御塔和玩家，就以水晶为攻击目标。

怪物攻击逻辑写在一个函数里，在攻击动画的关键帧执行。

### 刷怪点

刷怪点可以配置刷怪的波数，出怪间隔以及出怪类型等信息，

主要使用Invoke函数实现间隔时间出怪和更新波数的功能。

